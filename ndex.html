<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leren over Sinus, Cosinus & Tangens (D3.js, Dark Mode)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f9ff;
            --text-color: #333;
            --container-bg: #ffffff;
            --header-color: #005A9C;
            --explanation-subtitle-color: #007bff;
            --section-bg: #e7f5ff;
            --section-border: #bde0fe;
            --diagram-wrapper-bg: #f8f9fa;
            --diagram-wrapper-border: #dee2e6;
            --input-bg: #fff;
            --input-text: #333;
            --input-border: #ced4da;
            --button-primary-bg: #007bff;
            --button-primary-text: white;
            --button-primary-hover-bg: #0056b3;
            --button-secondary-bg: #6c757d;
            --button-secondary-text: white;
            --button-secondary-hover-bg: #5a6268;
            --feedback-correct-text: #155724;
            --feedback-correct-bg: #d4edda;
            --feedback-correct-border: #c3e6cb;
            --feedback-incorrect-text: #721c24;
            --feedback-incorrect-bg: #f8d7da;
            --feedback-incorrect-border: #f5c6cb;
            --uitleg-extra-bg: #fff3cd;
            --uitleg-extra-border: #ffeeba;
            --uitleg-stap-bg: #e7f5ff;
            --uitleg-stap-border: #007bff;
            --uitleg-stap-header: #005A9C;
            --svg-default-stroke: #333;
            --svg-highlight-stroke: #d9534f;
            --svg-text-highlight-fill: #d9534f; /* For highlighted text elements */
            --svg-vertex-label-fill: #005A9C;
            --svg-side-label-fill: #007bff;
            --svg-angle-label-fill: red;
            --svg-right-angle-stroke: #555;
            --svg-arc-fill: rgba(255,0,0,0.3);
            --svg-arc-highlight-fill: rgba(255,0,0,0.5);
            --link-color: #007bff;
        }

        body.dark-mode {
            --bg-color: #1a1a1a; /* Donkerder grijs/zwart */
            --text-color: #e0e0e0; /* Lichtgrijs */
            --container-bg: #2c2c2c; /* Donkergrijs */
            --header-color: #66b2ff; /* Lichter blauw */
            --explanation-subtitle-color: #80c7ff; /* Nog lichter blauw */
            --section-bg: #383838; /* Medium donkergrijs */
            --section-border: #555555; /* Grijs */
            --diagram-wrapper-bg: #222222; /* Zeer donkergrijs */
            --diagram-wrapper-border: #4a4a4a; /* Donkergrijs */
            --input-bg: #3e3e3e; /* Donkergrijs */
            --input-text: #e0e0e0; /* Lichtgrijs */
            --input-border: #666666; /* Grijs */
            --button-primary-bg: #66b2ff; /* Lichter blauw */
            --button-primary-text: #1a1a1a; /* Zeer donkergrijs voor contrast */
            --button-primary-hover-bg: #80c7ff; /* Nog lichter blauw */
            --button-secondary-bg: #5a6268; /* Medium grijs */
            --button-secondary-text: #e0e0e0; /* Lichtgrijs */
            --button-secondary-hover-bg: #707880; /* Lichter medium grijs */
            --feedback-correct-text: #a7f0ba; /* Lichtgroen */
            --feedback-correct-bg: #223e2b; /* Donkergroen */
            --feedback-correct-border: #355e40; /* Medium donkergroen */
            --feedback-incorrect-text: #f5b9c0; /* Lichtrood */
            --feedback-incorrect-bg: #4a2328; /* Donkerrood */
            --feedback-incorrect-border: #70363d; /* Medium donkerrood */
            --uitleg-extra-bg: #4d432c; /* Donkergeel/bruin */
            --uitleg-extra-border: #806f44; /* Medium donkergeel/bruin */
            --uitleg-stap-bg: #383838; /* Medium donkergrijs */
            --uitleg-stap-border: #66b2ff; /* Lichter blauw */
            --uitleg-stap-header: #66b2ff; /* Lichter blauw */
            --svg-default-stroke: #c9d1d9; /* Lichtgrijs */
            --svg-highlight-stroke: #ff8c82; /* Lichter rood/oranje */
            --svg-text-highlight-fill: #ff8c82;
            --svg-vertex-label-fill: #66b2ff; /* Lichter blauw */
            --svg-side-label-fill: #80c7ff; /* Nog lichter blauw */
            --svg-angle-label-fill: #ff8080; /* Lichter rood */
            --svg-right-angle-stroke: #888888; /* Grijs */
            --svg-arc-fill: rgba(255,128,128,0.3); /* Lichter rood, transparant */
            --svg-arc-highlight-fill: rgba(255,128,128,0.5); /* Lichter rood, meer dekkend */
            --link-color: #66b2ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 20px;
            padding-bottom: 20px;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 800px;
            width: 90%;
            margin: 20px auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transition: background-color 0.3s;
        }
        h1, h2 {
            color: var(--header-color);
            text-align: center;
            margin-bottom: 20px;
        }
        h3.explanation-subtitle {
            color: var(--explanation-subtitle-color);
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--section-border);
            padding-bottom: 5px;
        }
        .explanation, .quiz, .feedback-section, .selection-menu {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid var(--section-border);
            border-radius: 8px;
            background-color: var(--section-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .triangle-container-wrapper, #triangle-diagram {
            text-align: center;
            margin-bottom: 15px;
            background-color: var(--diagram-wrapper-bg);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid var(--diagram-wrapper-border);
            transition: background-color 0.3s, border-color 0.3s;
        }
        svg { /* SVG inherits fill/stroke from CSS if not set directly */
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        input[type="number"] {
            padding: 10px;
            margin-right: 10px;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--input-text);
            border-radius: 6px;
            font-size: 1rem;
            width: calc(50% - 15px);
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }
        button {
            padding: 12px 20px;
            background-color: var(--button-primary-bg);
            color: var(--button-primary-text);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, color 0.3s ease;
            margin-top: 10px;
        }
        button:hover { background-color: var(--button-primary-hover-bg); }
        #toggleExplanationButton, #darkModeToggle {
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            margin-left: 5px; /* Add some space between buttons */
        }
        #toggleExplanationButton:hover, #darkModeToggle:hover {
            background-color: var(--button-secondary-hover-bg);
        }

        .streak-counter {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: var(--header-color);
            margin-bottom: 15px;
        }
        .streak-counter span {
            color: var(--explanation-subtitle-color); /* Using a contrasting theme color */
            font-size: 1.3em;
        }

        .correct { color: var(--feedback-correct-text); background-color: var(--feedback-correct-bg); border: 1px solid var(--feedback-correct-border); padding: 10px; border-radius: 6px; }
        .incorrect { color: var(--feedback-incorrect-text); background-color: var(--feedback-incorrect-bg); border: 1px solid var(--feedback-incorrect-border); padding: 10px; border-radius: 6px; }
        #feedback { margin-top: 15px; font-weight: bold; min-height: 50px; }
        .uitleg-extra {
            display: block;
            margin-top:15px;
            padding:15px;
            background-color: var(--uitleg-extra-bg);
            border: 1px solid var(--uitleg-extra-border);
            border-radius: 6px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        ul { list-style-position: inside; padding-left: 20px; }
        li { margin-bottom: 8px; }
        .explanation ul li { margin-bottom: 10px; }
        .explanation p { margin-bottom: 12px; }

        /* SVG specific styles using CSS variables */
        .triangle-side { stroke: var(--svg-default-stroke); stroke-linecap: round; }
        .triangle-side.highlighted-stroke { stroke: var(--svg-highlight-stroke); }
        
        .vertex-label { font-family: 'Inter', sans-serif; fill: var(--svg-vertex-label-fill); font-weight: bold; }
        .vertex-label.highlighted-fill { fill: var(--svg-text-highlight-fill); } /* If needed */

        .side-label { font-family: 'Inter', sans-serif; fill: var(--svg-side-label-fill); text-anchor: middle; }
        .side-label.highlighted-fill { fill: var(--svg-text-highlight-fill); }
        
        .angle-label-text { font-family: 'Inter', sans-serif; fill: var(--svg-angle-label-fill); font-weight: bold; }
        .angle-label-text.highlighted-fill { fill: var(--svg-text-highlight-fill); }

        .angle-arc { fill: var(--svg-arc-fill); }
        .angle-arc.highlighted-fill { fill: var(--svg-arc-highlight-fill); }

        .right-angle-symbol { stroke: var(--svg-right-angle-stroke); fill: none; }


        #uitleg-fout-stappen-container .stap-uitleg {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px dashed var(--uitleg-stap-border);
            border-radius: 6px;
            background-color: var(--uitleg-stap-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        #uitleg-fout-stappen-container h5 {
            color: var(--uitleg-stap-header);
            margin-top: 0;
        }
        #uitleg-fout-stappen-container svg {
            border: 1px solid var(--diagram-wrapper-border); /* Use a theme variable */
            background-color: var(--container-bg); /* Use a theme variable */
            transition: background-color 0.3s, border-color 0.3s;
        }

        .selection-menu h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--header-color);
            font-size: 1.2em;
            text-align: left;
        }
        .selection-menu .checkbox-group { 
            margin-bottom: 10px;
            display: flex; 
            align-items: center;
        }
        .selection-menu label {
            margin-left: 8px;
            font-size: 1em; 
            color: var(--text-color);
            cursor: pointer;
        }
        .selection-menu input[type="checkbox"] {
            transform: scale(1.2); 
            cursor: pointer;
            margin-right: 5px; 
        }
        .button-group { /* For grouping buttons like Uitleg and Dark Mode */
            text-align: center;
            margin-bottom: 20px;
        }

        @media (max-width: 600px) {
            .container { width: 95%; padding: 15px; }
            input[type="number"] { width: calc(100% - 20px); margin-bottom: 10px; }
            button { width: 100%; margin-top: 5px; }
            #toggleExplanationButton, #darkModeToggle { width: auto; margin: 5px; } /* Adjust for smaller screens */
            .button-group button { width: auto; display: inline-block; margin: 5px; }


            h1 { font-size: 1.8rem; }
            h2 { font-size: 1.5rem; }
            .selection-menu h3 { font-size: 1.1em; }
            .selection-menu label { font-size: 0.9em; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <h1>üìê Sinus, Cosinus en Tangens Leren</h1>
        <div class="button-group">
            <button id="toggleExplanationButton">Toon Uitleg</button>
            <button id="darkModeToggle">üåô Dark Mode</button>
        </div>
        <div class="streak-counter">Winnende streak: <span id="streakValue">0</span></div>

        <div class="explanation" style="display: none;">
            <h2>Uitleg: SOL CAL TOA</h2>
            <p>In een <strong>rechthoekige driehoek</strong> kunnen we de sinus, cosinus en tangens gebruiken om de lengte van zijdes of de grootte van hoeken te berekenen. De driehoek heeft √©√©n rechte hoek (90¬∞). De zijdes hebben speciale namen ten opzichte van √©√©n van de andere (scherpe) hoeken, bijvoorbeeld hoek A:</p>
             <ul>
                <li><strong>Langste zijde (L):</strong> Altijd de zijde tegenover de rechte hoek. Dit is de langste zijde van de driehoek. (Ook wel hypotenusa genoemd)</li>
                <li><strong>Overstaande rechthoekszijde (O):</strong> De zijde die tegenover de hoek staat waaruit je kijkt (hoek A in dit geval).</li>
                <li><strong>Aanliggende rechthoekszijde (A):</strong> De rechthoekszijde die aan de hoek (hoek A) vastzit, maar niet de langste zijde is.</li>
            </ul>
            <div class="triangle-container-wrapper">
                <p>Stel je een rechthoekige driehoek ABC voor, met de rechte hoek bij C. We kijken vanuit hoek A.</p>
                <svg id="explanationTriangleSvg" width="250" height="200"></svg>
                <p>(Dit is een voorbeeld driehoek.)</p>
            </div>
            <p>De basisregels (ezelsbruggetje: <strong>SOL CAL TOA</strong>):</p>
            <ul>
                <li><strong>S</strong>OL: <strong>S</strong>inus (hoek Œ±) = <strong>O</strong>verstaande / <strong>L</strong>angste  ($$\sin(\alpha) = \frac{O}{L}$$)</li>
                <li><strong>C</strong>AL: <strong>C</strong>osinus (hoek Œ±) = <strong>A</strong>anliggende / <strong>L</strong>angste ($$\cos(\alpha) = \frac{A}{L}$$)</li>
                <li><strong>T</strong>OA: <strong>T</strong>angens (hoek Œ±) = <strong>O</strong>verstaande / <strong>A</strong>anliggende ($$\tan(\alpha) = \frac{O}{A}$$)</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende ZIJDE?</h3>
            <p>Als je √©√©n hoek (niet de rechte hoek) en √©√©n zijde weet, kun je een andere zijde berekenen.</p>
            <ol>
                <li><strong>Identificeer de bekende hoek ($\alpha$).</strong></li>
                <li><strong>Identificeer de bekende zijde:</strong> Is het de Overstaande (O), Aanliggende (A), of Langste (L) zijde ten opzichte van de bekende hoek?</li>
                <li><strong>Identificeer de onbekende zijde:</strong> Is dit O, A, of L?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die zowel de bekende zijde, de onbekende zijde, als de bekende hoek bevat.</li>
                <li><strong>Herschrijf de formule</strong> indien nodig om de onbekende zijde te isoleren.</li>
                <li><strong>Vul de bekende waarden in</strong> en reken de onbekende zijde uit.</li>
            </ol>
            <p><strong>Voorbeeld: Een zijde berekenen</strong></p>
            <p>Stel, hoek A = 30¬∞, en de Langste zijde (L) = 10 cm. We willen de Overstaande zijde (O) weten.</p>
            <ul>
                <li>Bekende hoek: $\alpha = 30¬∞$</li>
                <li>Bekende zijde: L = 10 cm</li>
                <li>Onbekende zijde: O = ?</li>
                <li>Formule: We hebben O en L, dus we gebruiken <strong>SOL</strong>:  $$\sin(\alpha) = \frac{O}{L}$$</li>
                <li>Herschrijven: Om O te vinden, vermenigvuldigen we beide kanten met L: $$O = L \times \sin(\alpha)$$</li>
                <li>Invullen: $$O = 10 \times \sin(30¬∞) = 10 \times 0.5 = 5 \text{ cm}$$</li>
            </ul>
            <p>Andere vormen:</p>
            <ul>
                <li>Als je O weet en L zoekt met sin: $$L = \frac{O}{\sin(\alpha)}$$</li>
                <li>Als je A weet en L zoekt met cos: $$L = \frac{A}{\cos(\alpha)}$$</li>
                <li>Als je L weet en A zoekt met cos: $$A = L \times \cos(\alpha)$$</li>
                <li>Als je O weet en A zoekt met tan: $$A = \frac{O}{\tan(\alpha)}$$</li>
                <li>Als je A weet en O zoekt met tan: $$O = A \times \tan(\alpha)$$</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende HOEK?</h3>
            <p>Als je twee zijdes van de rechthoekige driehoek weet, kun je een hoek berekenen met de inverse goniometrische functies: $\sin^{-1}$ (arcsinus), $\cos^{-1}$ (arccosinus), of $\tan^{-1}$ (arctangens).</p>
            <ol>
                <li><strong>Identificeer de hoek ($\alpha$) die je wilt berekenen.</strong></li>
                <li><strong>Identificeer de twee bekende zijdes:</strong> Zijn dit O, A, en/of L ten opzichte van de te berekenen hoek?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die deze twee bekende zijdes bevat.</li>
                <li><strong>Bereken de verhouding</strong> van de zijdes (bijv. O/L).</li>
                <li><strong>Gebruik de bijbehorende inverse functie</strong> op je rekenmachine om de hoek te vinden. Zorg dat je rekenmachine op graden (degrees) staat!</li>
            </ol>
            <p><strong>Voorbeeld: Een hoek berekenen</strong></p>
            <p>Stel, de Overstaande zijde (O) = 6 cm, en de Aanliggende zijde (A) = 8 cm. We willen hoek $\alpha$ weten.</p>
            <ul>
                <li>Te berekenen hoek: $\alpha = ?$</li>
                <li>Bekende zijdes: O = 6 cm, A = 8 cm</li>
                <li>Formule: We hebben O en A, dus we gebruiken <strong>TOA</strong>: $$\tan(\alpha) = \frac{O}{A}$$</li>
                <li>Verhouding: $$\tan(\alpha) = \frac{6}{8} = 0.75$$</li>
                <li>Inverse functie: $$\alpha = \tan^{-1}(0.75)$$</li>
                <li>Uitkomst (met rekenmachine): $$\alpha \approx 36.87¬∞$$</li>
            </ul>
             <p>De inverse formules zijn dus:</p>
            <ul>
                <li>$$ \alpha = \sin^{-1}\left(\frac{O}{L}\right) $$</li>
                <li>$$ \alpha = \cos^{-1}\left(\frac{A}{L}\right) $$</li>
                <li>$$ \alpha = \tan^{-1}\left(\frac{O}{A}\right) $$</li>
            </ul>
        </div>

        <div class="selection-menu">
            <h3>Kies wat je wilt oefenen:</h3>
            <div class="checkbox-group">
                <input type="checkbox" id="selectSinSides" name="questionType" value="sinSides" checked>
                <label for="selectSinSides">Sinus (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectCosSides" name="questionType" value="cosSides" checked>
                <label for="selectCosSides">Cosinus (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectTanSides" name="questionType" value="tanSides" checked>
                <label for="selectTanSides">Tangens (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectAngles" name="questionType" value="angles" checked>
                <label for="selectAngles">Hoeken berekenen (met sin, cos, of tan)</label>
            </div>
        </div>

        <div class="quiz">
            <h2>üéì Overhoring: Tijd om te oefenen!</h2>
            <p id="question">Klik op "Nieuwe Vraag" om te beginnen.</p>
            <div id="triangle-diagram">
                 <svg id="questionTriangleSvg" width="300" height="225"></svg>
            </div>
            <div>
                <label for="answer" id="answerLabel">Antwoord (getal, 1 decimaal): </label>
                <input type="number" id="answer" step="0.1" placeholder="bv. 7.3">
            </div>
            <button onclick="checkAnswer()">Controleer Antwoord</button>
            <button onclick="newQuestion()">Nieuwe Vraag</button>
            <div id="feedback" class="feedback-section"></div>
            <div id="uitleg-fout" class="uitleg-extra" style="display:none;">
                <h4>Uitleg van de oplossing:</h4>
                <p>De gebruikte regel was: <strong id="uitleg-fout-regel"></strong></p>
                <p>De berekening was: <strong id="uitleg-fout-berekening"></strong></p>
                <div id="uitleg-fout-stappen-container" style="margin-top: 15px;">
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionData = {};
        let currentStreak = 0;
        let lastQuestionTypeOnError = null; 

        const questionElement = document.getElementById('question');
        const answerElement = document.getElementById('answer');
        const answerLabelElement = document.getElementById('answerLabel');
        const feedbackElement = document.getElementById('feedback');
        const uitlegFoutElement = document.getElementById('uitleg-fout');
        const uitlegFoutRegel = document.getElementById('uitleg-fout-regel');
        const uitlegFoutBerekening = document.getElementById('uitleg-fout-berekening');
        const uitlegStappenContainer = document.getElementById('uitleg-fout-stappen-container');
        const explanationDiv = document.querySelector('.explanation');
        const toggleExplanationButton = document.getElementById('toggleExplanationButton');
        const darkModeToggleButton = document.getElementById('darkModeToggle');
        const streakValueElement = document.getElementById('streakValue');

        const selectSinSidesCb = document.getElementById('selectSinSides');
        const selectCosSidesCb = document.getElementById('selectCosSides');
        const selectTanSidesCb = document.getElementById('selectTanSides');
        const selectAnglesCb = document.getElementById('selectAngles');

        // Dark Mode Logic
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                darkModeToggleButton.textContent = '‚òÄÔ∏è Light Mode';
            } else {
                document.body.classList.remove('dark-mode');
                darkModeToggleButton.textContent = 'üåô Dark Mode';
            }
        }

        darkModeToggleButton.addEventListener('click', () => {
            let currentTheme = localStorage.getItem('theme');
            if (document.body.classList.contains('dark-mode')) { // If currently dark, switch to light
                currentTheme = 'light';
            } else { // If currently light, switch to dark
                currentTheme = 'dark';
            }
            localStorage.setItem('theme', currentTheme);
            applyTheme(currentTheme);
            // Re-draw triangles if they are visible to apply new theme styles to SVG elements
            if (explanationDiv.style.display === 'block' && document.getElementById('explanationTriangleSvg').childNodes.length > 0) {
                drawExplanationTriangle();
            }
            if (document.getElementById('questionTriangleSvg').childNodes.length > 0 && currentQuestionData.full_side_l) { // Check if a question is loaded
                 redrawCurrentQuestionTriangle(); // A new function to redraw the existing question triangle
            }
            if (uitlegFoutElement.style.display === 'block' && currentQuestionData.full_side_l) {
                toonUitlegStappen(currentQuestionData); // Redraw explanation steps
            }
        });
        
        function redrawCurrentQuestionTriangle() {
            if (!currentQuestionData || Object.keys(currentQuestionData).length === 0) return;

            let q_l = null, q_o = null, q_a = null;
            let angleForDrawing = null; 

            if (currentQuestionData.isAngleQuestion) {
                q_l = currentQuestionData.full_side_l; 
                q_o = currentQuestionData.full_side_o; 
                q_a = currentQuestionData.full_side_a;
                angleForDrawing = null; 
                drawTriangleGeneric("questionTriangleSvg", angleForDrawing, q_l, q_o, q_a, "A", "L", "O", "A", currentQuestionData.knownSideKey, null, null, false, true);
            } else { 
                angleForDrawing = currentQuestionData.angleA; 
                if (currentQuestionData.knownSideKey === 'L') q_l = currentQuestionData.knownSideValue;
                else if (currentQuestionData.knownSideKey === 'O') q_o = currentQuestionData.knownSideValue;
                else if (currentQuestionData.knownSideKey === 'A') q_a = currentQuestionData.knownSideValue;
                
                if (currentQuestionData.teVindenKey === 'L') q_l = null;
                else if (currentQuestionData.teVindenKey === 'O') q_o = null;
                else if (currentQuestionData.teVindenKey === 'A') q_a = null;
                
                // Ensure other sides are filled for drawing if not the one being asked
                if (q_l === null && currentQuestionData.teVindenKey !== 'L') q_l = currentQuestionData.full_side_l;
                if (q_o === null && currentQuestionData.teVindenKey !== 'O') q_o = currentQuestionData.full_side_o;
                if (q_a === null && currentQuestionData.teVindenKey !== 'A') q_a = currentQuestionData.full_side_a;

                drawTriangleGeneric("questionTriangleSvg", angleForDrawing, q_l, q_o, q_a, "A", "L", "O", "A", currentQuestionData.teVindenKey, null, null, false, false);
            }
        }


        toggleExplanationButton.addEventListener('click', function() {
            if (explanationDiv.style.display === 'none' || explanationDiv.style.display === '') {
                explanationDiv.style.display = 'block';
                toggleExplanationButton.textContent = 'Verberg Uitleg';
                if (document.getElementById('explanationTriangleSvg').childNodes.length === 0) { 
                     drawExplanationTriangle();
                }
            } else {
                explanationDiv.style.display = 'none';
                toggleExplanationButton.textContent = 'Toon Uitleg';
            }
        });

        function updateStreakDisplay() {
            streakValueElement.textContent = currentStreak;
        }

        function toRadians(degrees) { return degrees * (Math.PI / 180); }
        function toDegrees(radians) { return radians * (180 / Math.PI); }

        function drawExplanationTriangle() {
            const angleA_deg = 30;
            const side_a_expl = 10; 
            const side_o_expl = side_a_expl * Math.tan(toRadians(angleA_deg)); 
            const side_l_expl = side_a_expl / Math.cos(toRadians(angleA_deg)); 
            drawTriangleGeneric("explanationTriangleSvg", angleA_deg, side_l_expl, side_o_expl, side_a_expl, "Hoek A", "Langste (L)", "Overst. (O)", "Aanlig. (A)", null, 250, 200, true, false);
        }

        function drawTriangleGeneric(svgIdOrSelection, angleA_deg, side_l, side_o, side_a, labelAngleA, labelL, labelO, labelA, highlightKeys = null, customWidth = null, customHeight = null, showSidePrefixes = true, isAngleQuestion = false) { 
            const svg = (typeof svgIdOrSelection === 'string') ? d3.select("#" + svgIdOrSelection) : svgIdOrSelection;
            svg.selectAll("*").remove();

            const svgWidth = customWidth || parseFloat(svg.attr("width"));
            const svgHeight = customHeight || parseFloat(svg.attr("height"));

            const PADDING = customWidth ? 20 : 30; 
            const availableWidth = svgWidth - 2 * PADDING;
            const availableHeight = svgHeight - 2 * PADDING;

            let scale;
            const temp_angle_rad_for_scaling = toRadians(angleA_deg || 30);
            let ref_a = side_a, ref_o = side_o;

            if (side_l && side_l > 0) {
                if (side_a === null || side_a === undefined || side_a <= 0) ref_a = side_l * Math.cos(temp_angle_rad_for_scaling);
                if (side_o === null || side_o === undefined || side_o <= 0) ref_o = side_l * Math.sin(temp_angle_rad_for_scaling);
            }
            if (!ref_a || ref_a <= 0) ref_a = (ref_o && ref_o > 0 && temp_angle_rad_for_scaling > 0.01 && temp_angle_rad_for_scaling < Math.PI/2 - 0.01) ? ref_o / Math.tan(temp_angle_rad_for_scaling) : 10;
            if (!ref_o || ref_o <= 0) ref_o = (ref_a && ref_a > 0 && temp_angle_rad_for_scaling > 0.01 && temp_angle_rad_for_scaling < Math.PI/2 - 0.01) ? ref_a * Math.tan(temp_angle_rad_for_scaling) : 10;

            const scaleX = ref_a > 0.1 ? availableWidth / ref_a : availableWidth / 10; 
            const scaleY = ref_o > 0.1 ? availableHeight / ref_o : availableHeight / 10; 
            scale = Math.min(scaleX, scaleY);
            scale = Math.max(customWidth ? 2 : 3, Math.min(scale, customWidth ? 15 : 25)); 

            const actual_angle_rad = (angleA_deg !== null && angleA_deg !== undefined) ? toRadians(angleA_deg) : temp_angle_rad_for_scaling;
            const scaled_a_val = side_a !== null && side_a !== undefined ? side_a * scale : ( (side_l !== null && side_l !== undefined && side_o !== null && side_o !== undefined) ? Math.sqrt(Math.max(0.1,(side_l*scale)**2 - (side_o*scale)**2)) : ( (side_l !== null && side_l !== undefined) ? (side_l*scale) * Math.cos(actual_angle_rad) : ( (side_o !== null && side_o !== undefined && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) ? (side_o*scale) / Math.tan(actual_angle_rad) : 10*scale ) ) );
            const scaled_o_val = side_o !== null && side_o !== undefined ? side_o * scale : ( (side_l !== null && side_l !== undefined && side_a !== null && side_a !== undefined) ? Math.sqrt(Math.max(0.1,(side_l*scale)**2 - (side_a*scale)**2)) : ( (side_l !== null && side_l !== undefined) ? (side_l*scale) * Math.sin(actual_angle_rad) : ( (side_a !== null && side_a !== undefined && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) ? (side_a*scale) * Math.tan(actual_angle_rad) : 10*scale*Math.tan(actual_angle_rad) ) ) );
            const final_scaled_a = Math.max(1, scaled_a_val); 
            const final_scaled_o = Math.max(1, scaled_o_val);

            const Cx = PADDING; const Cy = svgHeight - PADDING;
            const Ax = Cx + final_scaled_a; const Ay = Cy;
            const Bx = Cx; const By = Cy - final_scaled_o;
            const group = svg.append("g");

            const sidesData = [
                { id: 'AC', x1: Cx, y1: Cy, x2: Ax, y2: Ay, label: labelA, value: side_a, key: 'A', name: "Aanliggende" },
                { id: 'BC', x1: Cx, y1: Cy, x2: Bx, y2: By, label: labelO, value: side_o, key: 'O', name: "Overstaande" },
                { id: 'AB', x1: Ax, y1: Ay, x2: Bx, y2: By, label: labelL, value: side_l, key: 'L', name: "Langste" }
            ];
            const isHighlighted = (key) => highlightKeys && (Array.isArray(highlightKeys) ? highlightKeys.includes(key) : highlightKeys === key);

            group.selectAll("line.triangle-side")
                .data(sidesData).join(
                    enter => enter.append("line")
                        .attr("class", d => "triangle-side" + (isHighlighted(d.key) ? " highlighted-stroke" : ""))
                        .attr("x1", d => d.x1).attr("y1", d => d.y1)
                        .attr("x2", d => d.x1).attr("y2", d => d.y1) 
                        .attr("stroke-width", d => isHighlighted(d.key) ? (customWidth ? 2.5 : 3.5) : (customWidth ? 1.5 : 2))
                        .transition().duration(customWidth ? 300 : 750).attr("x2", d => d.x2).attr("y2", d => d.y2)
                );
            
            const vertexData = [
                { id: 'A', x: Ax + (customWidth ? 4 : 8), y: Ay + (customWidth ? 9 : 18), label: 'A' },
                { id: 'B', x: Bx - (customWidth ? 5 : 10), y: By - (customWidth ? 4 : 8), label: 'B' },
                { id: 'C', x: Cx - (customWidth ? 7 : 15), y: Cy + (customWidth ? 7 : 15), label: 'C' }
            ];
            group.selectAll("text.vertex-label").data(vertexData).join("text")
                .attr("class", d => "vertex-label" + (isHighlighted(d.key) ? " highlighted-fill" : "")) // Assuming vertex can be highlighted
                .attr("x", d => d.x).attr("y", d => d.y).text(d => d.label)
                .style("font-size", customWidth ? "10px" : "14px")
                .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 200:600).style("opacity", 1);

            group.selectAll("text.side-label").data(sidesData.filter(d => (d.value !== null && d.value !== undefined) || (isHighlighted(d.key) && showSidePrefixes))) 
                .join("text")
                .attr("class", d => "side-label" + (isHighlighted(d.key) ? " highlighted-fill" : ""))
                .attr("x", d => (d.id === 'AC') ? (d.x1 + d.x2) / 2 : (d.id === 'BC') ? d.x1 - (customWidth ? 5 : 10) : (d.x1 + d.x2) / 2)
                .attr("y", d => (d.id === 'AC') ? d.y1 + (customWidth ? 10 : 20) : (d.id === 'BC') ? (d.y1 + d.y2) / 2 + (customWidth ? 2 : 4) : (d.y1 + d.y2) / 2 - (customWidth ? 6 : 12))
                .attr("transform", d => {
                    if (d.id === 'AB' && (showSidePrefixes || (d.value !== null && d.value !== undefined))) { 
                         const angleRad = Math.atan2(By - Ay, Bx - Ax); let textAngle = toDegrees(angleRad);
                         return `rotate(${textAngle}, ${(d.x1+d.x2)/2}, ${(d.y1+d.y2)/2})`;
                    } return ""; 
                })
                .attr("text-anchor", d => (d.id === 'BC' ? "end" : "middle"))
                .text(d => {
                    const valueText = (d.value !== null && d.value !== undefined) ? d.value.toFixed(1) : '?';
                    const prefix = d.label.split(" ")[0]; 
                    if (showSidePrefixes) return `${prefix}: ${valueText}${(valueText === '?' && isHighlighted(d.key) ? ` (${d.name.substring(0,6)}...)` : '')}`;
                    return valueText;
                })
                .style("font-weight", d => isHighlighted(d.key) ? "bold" : "normal")
                .style("font-size", customWidth ? "9px" : "12px")
                .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 250:700).style("opacity", 1);

            let angleDisplayText = ""; const anglePrefix = labelAngleA.split(" ")[0];
            if (angleA_deg !== null && angleA_deg !== undefined) angleDisplayText = `${anglePrefix}: ${angleA_deg.toFixed(1)}¬∞`;
            else if (isHighlighted('angleA') && showSidePrefixes) angleDisplayText = `${anglePrefix}: ?`;
            else if (isAngleQuestion && !showSidePrefixes && !isHighlighted('angleA')) angleDisplayText = `${anglePrefix}: ?`;

            if (angleDisplayText) {
                group.append("text")
                    .attr("class", "angle-label-text" + (isHighlighted('angleA') ? " highlighted-fill" : ""))
                    .attr("x", Ax - (customWidth ? 15 : (final_scaled_a > 30 ? 30: 15)) ).attr("y", Ay - (customWidth ? 5 : 10))
                    .text(angleDisplayText).style("font-size", customWidth ? "9px" : "12px")
                    .style("font-weight", isHighlighted('angleA') ? "bold" : "bold") // fontWeight can stay if it's just bold
                    .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 250:700).style("opacity", 1);
            }
            
            if (angleA_deg !== null && angleA_deg !== undefined) { 
                const arcRadius = Math.min((customWidth ? 12 : 25), final_scaled_a / 3, final_scaled_o / 3);
                if (arcRadius > (customWidth ? 2 : 5)) { 
                     const arcGenerator = d3.arc().innerRadius(arcRadius - (customWidth ? 1 : 2)).outerRadius(arcRadius).startAngle(Math.PI).endAngle(Math.PI + toRadians(angleA_deg)); 
                    group.append("path").attr("class", "angle-arc" + (isHighlighted('angleA') ? " highlighted-fill" : ""))
                        .attr("transform", `translate(${Ax}, ${Ay})`).attr("d", arcGenerator)
                        .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 300:750).style("opacity", 1);
                }
            }
            group.append("path").attr("class", "right-angle-symbol")
                .attr("d", `M ${Cx + (customWidth ? 5:10)} ${Cy} L ${Cx + (customWidth ? 5:10)} ${Cy - (customWidth ? 5:10)} L ${Cx} ${Cy - (customWidth ? 5:10)}`) 
                .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 250:700).style("opacity", 1);
        }

        function newQuestion() {
            answerElement.value = '';
            feedbackElement.innerHTML = '';
            uitlegFoutElement.style.display = 'none';
            uitlegStappenContainer.innerHTML = ''; 
            updateStreakDisplay();

            let questionCategory, mainType, subType; 
            let selectedQuestionPool = [];
            if (selectSinSidesCb.checked) selectedQuestionPool.push({category: 0, mainType: 0});
            if (selectCosSidesCb.checked) selectedQuestionPool.push({category: 0, mainType: 1});
            if (selectTanSidesCb.checked) selectedQuestionPool.push({category: 0, mainType: 2});
            if (selectAnglesCb.checked) {
                selectedQuestionPool.push({category: 1, mainType: 0}); 
                selectedQuestionPool.push({category: 1, mainType: 1}); 
                selectedQuestionPool.push({category: 1, mainType: 2});
            }

            if (selectedQuestionPool.length === 0) { 
                selectSinSidesCb.checked = true; selectCosSidesCb.checked = true; selectTanSidesCb.checked = true; selectAnglesCb.checked = true;
                selectedQuestionPool = [ {category: 0, mainType: 0}, {category: 0, mainType: 1}, {category: 0, mainType: 2}, {category: 1, mainType: 0}, {category: 1, mainType: 1}, {category: 1, mainType: 2} ];
                if(feedbackElement.innerHTML === '') feedbackElement.innerHTML = "<span class='incorrect'>Geen type geselecteerd. Alle types worden nu gebruikt.</span>";
            }

            if (lastQuestionTypeOnError) {
                const errorTypeStillSelected = selectedQuestionPool.some(type => type.category === lastQuestionTypeOnError.category && type.mainType === lastQuestionTypeOnError.mainType);
                if (errorTypeStillSelected) {
                    questionCategory = lastQuestionTypeOnError.category; mainType = lastQuestionTypeOnError.mainType; subType = lastQuestionTypeOnError.subType; 
                } else { 
                    const chosenType = selectedQuestionPool[Math.floor(Math.random() * selectedQuestionPool.length)];
                    questionCategory = chosenType.category; mainType = chosenType.mainType; subType = undefined;
                }
                lastQuestionTypeOnError = null; 
            } else {
                const chosenType = selectedQuestionPool[Math.floor(Math.random() * selectedQuestionPool.length)];
                questionCategory = chosenType.category; mainType = chosenType.mainType; subType = undefined;
            }
            if (questionCategory === 0 && subType === undefined) subType = Math.random() < 0.5 ? 0 : 1; 

            currentQuestionData.category = questionCategory; currentQuestionData.mainType = mainType; currentQuestionData.subType = subType; 
            let angleA, knownSideValue, side_l_calc, side_o_calc, side_a_calc, teVindenKey, knownSideKey, knownSideVal;
            let calculationDescription = ""; currentQuestionData.isAngleQuestion = (questionCategory === 1);

            if (!currentQuestionData.isAngleQuestion) { 
                answerLabelElement.textContent = "Antwoord (zijde, 1 decimaal):"; angleA = Math.floor(Math.random() * 50) + 20; 
                currentQuestionData.angleA = angleA; knownSideValue = parseFloat((Math.random() * 15 + 5).toFixed(1)); 
                if (mainType === 0) { // Sinus
                    if (subType === 0) { side_l_calc = knownSideValue; teVindenKey = 'O'; knownSideKey = 'L'; knownSideVal = side_l_calc; currentQuestionData.correctAnswer = side_l_calc * Math.sin(toRadians(angleA)); side_o_calc = currentQuestionData.correctAnswer; side_a_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_o_calc**2)); questionElement.innerText = `Hoek A = ${angleA}¬∞, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken de Overstaande zijde (O) van hoek A.`; currentQuestionData.rule = "SOL: sin(A) = O / L  =>  O = L * sin(A)"; calculationDescription = `O = ${side_l_calc.toFixed(1)} * sin(${angleA}¬∞)`; } 
                    else { side_o_calc = knownSideValue; teVindenKey = 'L'; knownSideKey = 'O'; knownSideVal = side_o_calc; currentQuestionData.correctAnswer = side_o_calc / Math.sin(toRadians(angleA)); side_l_calc = currentQuestionData.correctAnswer; side_a_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_o_calc**2)); questionElement.innerText = `Hoek A = ${angleA}¬∞, Overstaande zijde (O) = ${side_o_calc.toFixed(1)}. Bereken de Langste zijde (L).`; currentQuestionData.rule = "SOL: sin(A) = O / L  =>  L = O / sin(A)"; calculationDescription = `L = ${side_o_calc.toFixed(1)} / sin(${angleA}¬∞)`; }
                } else if (mainType === 1) { // Cosinus
                    if (subType === 0) { side_l_calc = knownSideValue; teVindenKey = 'A'; knownSideKey = 'L'; knownSideVal = side_l_calc; currentQuestionData.correctAnswer = side_l_calc * Math.cos(toRadians(angleA)); side_a_calc = currentQuestionData.correctAnswer; side_o_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_a_calc**2)); questionElement.innerText = `Hoek A = ${angleA}¬∞, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken de Aanliggende zijde (A) van hoek A.`; currentQuestionData.rule = "CAL: cos(A) = A / L  =>  A = L * cos(A)"; calculationDescription = `A = ${side_l_calc.toFixed(1)} * cos(${angleA}¬∞)`; } 
                    else { side_a_calc = knownSideValue; teVindenKey = 'L'; knownSideKey = 'A'; knownSideVal = side_a_calc; currentQuestionData.correctAnswer = side_a_calc / Math.cos(toRadians(angleA)); side_l_calc = currentQuestionData.correctAnswer; side_o_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_a_calc**2)); questionElement.innerText = `Hoek A = ${angleA}¬∞, Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}. Bereken de Langste zijde (L).`; currentQuestionData.rule = "CAL: cos(A) = A / L  =>  L = A / cos(A)"; calculationDescription = `L = ${side_a_calc.toFixed(1)} / cos(${angleA}¬∞)`; }
                } else { // Tangens
                    if (subType === 0) { side_a_calc = knownSideValue; teVindenKey = 'O'; knownSideKey = 'A'; knownSideVal = side_a_calc; currentQuestionData.correctAnswer = side_a_calc * Math.tan(toRadians(angleA)); side_o_calc = currentQuestionData.correctAnswer; side_l_calc = Math.sqrt(side_a_calc**2 + side_o_calc**2); questionElement.innerText = `Hoek A = ${angleA}¬∞, Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}. Bereken de Overstaande zijde (O) van hoek A.`; currentQuestionData.rule = "TOA: tan(A) = O / A  =>  O = A * tan(A)"; calculationDescription = `O = ${side_a_calc.toFixed(1)} * tan(${angleA}¬∞)`; } 
                    else { side_o_calc = knownSideValue; teVindenKey = 'A'; knownSideKey = 'O'; knownSideVal = side_o_calc; currentQuestionData.correctAnswer = side_o_calc / Math.tan(toRadians(angleA)); side_a_calc = currentQuestionData.correctAnswer; side_l_calc = Math.sqrt(side_a_calc**2 + side_o_calc**2); questionElement.innerText = `Hoek A = ${angleA}¬∞, Overstaande zijde (O) = ${side_o_calc.toFixed(1)}. Bereken de Aanliggende zijde (A) van hoek A.`; currentQuestionData.rule = "TOA: tan(A) = O / A  =>  A = O / tan(A)"; calculationDescription = `A = ${side_o_calc.toFixed(1)} / tan(${angleA}¬∞)`; }
                }
            } else { 
                answerLabelElement.textContent = "Antwoord (hoek in graden, 1 decimaal):"; teVindenKey = 'angleA'; 
                let side1Val = parseFloat((Math.random() * 10 + 5).toFixed(1)); let side2Val = parseFloat((Math.random() * 10 + 5).toFixed(1)); 
                if (mainType === 0) { side_o_calc = Math.min(side1Val, side2Val); side_l_calc = Math.max(side1Val, side2Val) + parseFloat((Math.random()*5+1).toFixed(1)); if (side_o_calc >= side_l_calc) side_l_calc = side_o_calc + parseFloat((Math.random()*2+0.5).toFixed(1)); side_a_calc = Math.sqrt(Math.max(0.1, side_l_calc**2 - side_o_calc**2)); currentQuestionData.correctAnswer = toDegrees(Math.asin(side_o_calc / side_l_calc)); knownSideKey = ['O', 'L']; knownSideVal = [side_o_calc, side_l_calc]; questionElement.innerText = `Overstaande zijde (O) = ${side_o_calc.toFixed(1)}, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken hoek A.`; currentQuestionData.rule = "SOL: sin(A) = O / L  =>  A = sin‚Åª¬π(O / L)"; calculationDescription = `A = sin‚Åª¬π(${side_o_calc.toFixed(1)} / ${side_l_calc.toFixed(1)})`;
                } else if (mainType === 1) { side_a_calc = Math.min(side1Val, side2Val); side_l_calc = Math.max(side1Val, side2Val) + parseFloat((Math.random()*5+1).toFixed(1)); if (side_a_calc >= side_l_calc) side_l_calc = side_a_calc + parseFloat((Math.random()*2+0.5).toFixed(1)); side_o_calc = Math.sqrt(Math.max(0.1, side_l_calc**2 - side_a_calc**2)); currentQuestionData.correctAnswer = toDegrees(Math.acos(side_a_calc / side_l_calc)); knownSideKey = ['A', 'L']; knownSideVal = [side_a_calc, side_l_calc]; questionElement.innerText = `Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken hoek A.`; currentQuestionData.rule = "CAL: cos(A) = A / L  =>  A = cos‚Åª¬π(A / L)"; calculationDescription = `A = cos‚Åª¬π(${side_a_calc.toFixed(1)} / ${side_l_calc.toFixed(1)})`;
                } else { side_o_calc = side1Val; side_a_calc = side2Val; side_l_calc = Math.sqrt(side_o_calc**2 + side_a_calc**2); currentQuestionData.correctAnswer = toDegrees(Math.atan(side_o_calc / side_a_calc)); knownSideKey = ['O', 'A']; knownSideVal = [side_o_calc, side_a_calc]; questionElement.innerText = `Overstaande zijde (O) = ${side_o_calc.toFixed(1)}, Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}. Bereken hoek A.`; currentQuestionData.rule = "TOA: tan(A) = O / A  =>  A = tan‚Åª¬π(O / A)"; calculationDescription = `A = tan‚Åª¬π(${side_o_calc.toFixed(1)} / ${side_a_calc.toFixed(1)})`; }
                angleA = currentQuestionData.correctAnswer; currentQuestionData.angleA = angleA; 
            }
            currentQuestionData.calculation = calculationDescription; currentQuestionData.teVindenKey = teVindenKey;
            currentQuestionData.knownSideKey = knownSideKey; currentQuestionData.knownSideValue = knownSideVal; 
            currentQuestionData.full_side_l = side_l_calc; currentQuestionData.full_side_o = side_o_calc; currentQuestionData.full_side_a = side_a_calc;
            redrawCurrentQuestionTriangle(); // Use the consolidated redraw function
        }

        function toonUitlegStappen(data) {
            uitlegStappenContainer.innerHTML = ''; uitlegFoutElement.style.display = 'block'; 
            const stepWidth = 200, stepHeight = 150;

            const stap1Div = d3.select(uitlegStappenContainer).append("div").attr("class", "stap-uitleg");
            stap1Div.append("h5").text("Stap 1: Wat weten we?");
            const svg1 = stap1Div.append("svg").attr("width", stepWidth).attr("height", stepHeight);
            let s1_angle_to_show = data.isAngleQuestion ? null : data.angleA; 
            drawTriangleGeneric(svg1, s1_angle_to_show, data.full_side_l, data.full_side_o, data.full_side_a, "A", "L", "O", "A", data.knownSideKey, stepWidth, stepHeight, true, data.isAngleQuestion);
            let gegevenText = data.isAngleQuestion ? `Gegeven: ${Array.isArray(data.knownSideKey) ? data.knownSideKey.map((k,i) => `${k === 'L' ? 'Langste' : (k === 'O' ? 'Overstaande' : 'Aanliggende')} = ${data.knownSideValue[i].toFixed(1)}`).join(', ') : ''}.`
                                                : `Gegeven: Hoek A = ${data.angleA.toFixed(1)}¬∞, ${data.knownSideKey === 'L' ? 'Langste' : (data.knownSideKey === 'O' ? 'Overstaande' : 'Aanliggende')} zijde = ${data.knownSideValue.toFixed(1)}.`;
            stap1Div.append("p").html(gegevenText);

            const stap2Div = d3.select(uitlegStappenContainer).append("div").attr("class", "stap-uitleg");
            stap2Div.append("h5").text("Stap 2: Formule kiezen en invullen");
            const svg2 = stap2Div.append("svg").attr("width", stepWidth).attr("height", stepHeight);
            let highlightFormuleKeys = [];
            if (data.rule.includes("SOL")) highlightFormuleKeys = ['O', 'L']; else if (data.rule.includes("CAL")) highlightFormuleKeys = ['A', 'L']; else if (data.rule.includes("TOA")) highlightFormuleKeys = ['O', 'A'];
            if (data.isAngleQuestion) highlightFormuleKeys.push('angleA'); else highlightFormuleKeys.push(data.teVindenKey);
            let s2_angle_to_show = data.isAngleQuestion ? null : data.angleA;
            drawTriangleGeneric(svg2, s2_angle_to_show, data.full_side_l, data.full_side_o, data.full_side_a, "A", "L", "O", "A", highlightFormuleKeys, stepWidth, stepHeight, true, data.isAngleQuestion);
            let teZoekenText = data.isAngleQuestion ? `Hoek A` : `de ${data.teVindenKey === 'L' ? 'Langste' : (data.teVindenKey === 'O' ? 'Overstaande' : 'Aanliggende')} zijde`;
            stap2Div.append("p").html(`We zoeken ${teZoekenText}.<br>Gebruik de regel: ${data.rule.split("=>")[0]}.<br>Invullen: ${data.calculation}.`);

            const stap3Div = d3.select(uitlegStappenContainer).append("div").attr("class", "stap-uitleg");
            stap3Div.append("h5").text("Stap 3: De Oplossing");
            const svg3 = stap3Div.append("svg").attr("width", stepWidth).attr("height", stepHeight);
            drawTriangleGeneric(svg3, data.angleA, data.full_side_l, data.full_side_o, data.full_side_a, "A", "L", "O", "A", [data.teVindenKey], stepWidth, stepHeight, true, data.isAngleQuestion);
            let oplossingText = data.isAngleQuestion ? `Hoek A is ongeveer <strong>${data.correctAnswer.toFixed(1)}¬∞</strong>.` : `De ${data.teVindenKey === 'L' ? 'Langste' : (data.teVindenKey === 'O' ? 'Overstaande' : 'Aanliggende')} zijde is ongeveer <strong>${data.correctAnswer.toFixed(1)}</strong>.`;
            stap3Div.append("p").html(oplossingText);
        }

        function checkAnswer() {
            const userAnswer = parseFloat(answerElement.value);
            if (isNaN(userAnswer)) {
                feedbackElement.innerHTML = "<span class='incorrect'>Voer alsjeblieft een getal in.</span>";
                uitlegStappenContainer.innerHTML = ''; uitlegFoutElement.style.display = 'none'; return;
            }
            const correctAnswerRounded = parseFloat(currentQuestionData.correctAnswer.toFixed(1));
            const userAnswerRounded = parseFloat(userAnswer.toFixed(1));

            if (userAnswerRounded === correctAnswerRounded) {
                feedbackElement.innerHTML = `<span class='correct'>üéâ Goed zo! Het antwoord is (ongeveer) ${correctAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}.</span>`;
                currentStreak++; lastQuestionTypeOnError = null; 
            } else {
                feedbackElement.innerHTML = `<span class='incorrect'>üò• Helaas, niet correct. Juiste antwoord: ${correctAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}. Jouw antwoord: ${userAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}.</span>`;
                currentStreak = 0; lastQuestionTypeOnError = { category: currentQuestionData.category, mainType: currentQuestionData.mainType, subType: currentQuestionData.subType };
            }
            updateStreakDisplay();
            uitlegFoutRegel.textContent = currentQuestionData.rule;
            uitlegFoutBerekening.textContent = currentQuestionData.calculation + ` ‚âà ${correctAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}`;
            toonUitlegStappen(currentQuestionData); 
        }

        answerElement.addEventListener('keypress', function(event) { if (event.key === 'Enter') checkAnswer(); });
        
        window.onload = function() { 
            const savedTheme = localStorage.getItem('theme') || 'light'; // Default to light
            applyTheme(savedTheme);
            newQuestion(); 
            if (document.getElementById('explanationTriangleSvg').childNodes.length === 0 && explanationDiv.style.display === 'block') {
                 drawExplanationTriangle(); 
            }
        };
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$']], displayMath: [['$$','$$']], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] }, messageStyle: "none" });
    </script>
</body>
</html>
