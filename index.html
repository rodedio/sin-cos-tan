<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leren over Sinus, Cosinus, Tangens & Pythagoras (D3.js, Dark Mode)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f9ff;
            --text-color: #333;
            --container-bg: #ffffff;
            --header-color: #005A9C;
            --explanation-subtitle-color: #007bff;
            --section-bg: #e7f5ff;
            --section-border: #bde0fe;
            --diagram-wrapper-bg: #f8f9fa;
            --diagram-wrapper-border: #dee2e6;
            --input-bg: #fff;
            --input-text: #333;
            --input-border: #ced4da;
            --button-primary-bg: #007bff;
            --button-primary-text: white;
            --button-primary-hover-bg: #0056b3;
            --button-secondary-bg: #6c757d;
            --button-secondary-text: white;
            --button-secondary-hover-bg: #5a6268;
            --feedback-correct-text: #155724;
            --feedback-correct-bg: #d4edda;
            --feedback-correct-border: #c3e6cb;
            --feedback-incorrect-text: #721c24;
            --feedback-incorrect-bg: #f8d7da;
            --feedback-incorrect-border: #f5c6cb;
            --uitleg-extra-bg: #fff3cd;
            --uitleg-extra-border: #ffeeba;
            --uitleg-stap-bg: #e7f5ff;
            --uitleg-stap-border: #007bff;
            --uitleg-stap-header: #005A9C;
            --svg-default-stroke: #333;
            --svg-highlight-stroke: #d9534f; /* Rood voor highlight */
            --svg-text-highlight-fill: #d9534f; /* Rood voor highlight tekst */
            --svg-vertex-label-fill: #005A9C;
            --svg-side-label-fill: #007bff;
            --svg-angle-label-fill: red;
            --svg-right-angle-stroke: #555;
            --svg-arc-fill: rgba(255,0,0,0.2); /* Lichter rood voor arc */
            --svg-arc-highlight-fill: rgba(255,0,0,0.4); /* Meer dekkend rood voor arc highlight */
            --link-color: #007bff;
        }

        body.dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --container-bg: #2c2c2c;
            --header-color: #66b2ff;
            --explanation-subtitle-color: #80c7ff;
            --section-bg: #383838;
            --section-border: #555555;
            --diagram-wrapper-bg: #222222;
            --diagram-wrapper-border: #4a4a4a;
            --input-bg: #3e3e3e;
            --input-text: #e0e0e0;
            --input-border: #666666;
            --button-primary-bg: #66b2ff;
            --button-primary-text: #1a1a1a;
            --button-primary-hover-bg: #80c7ff;
            --button-secondary-bg: #5a6268;
            --button-secondary-text: #e0e0e0;
            --button-secondary-hover-bg: #707880;
            --feedback-correct-text: #a7f0ba;
            --feedback-correct-bg: #223e2b;
            --feedback-correct-border: #355e40;
            --feedback-incorrect-text: #f5b9c0;
            --feedback-incorrect-bg: #4a2328;
            --feedback-incorrect-border: #70363d;
            --uitleg-extra-bg: #4d432c;
            --uitleg-extra-border: #806f44;
            --uitleg-stap-bg: #383838;
            --uitleg-stap-border: #66b2ff;
            --uitleg-stap-header: #66b2ff;
            --svg-default-stroke: #c9d1d9;
            --svg-highlight-stroke: #ff8c82; /* Lichter rood/oranje voor dark mode highlight */
            --svg-text-highlight-fill: #ff8c82;
            --svg-vertex-label-fill: #66b2ff;
            --svg-side-label-fill: #80c7ff;
            --svg-angle-label-fill: #ff8080; /* Lichter rood voor dark mode hoek */
            --svg-right-angle-stroke: #888888;
            --svg-arc-fill: rgba(255,128,128,0.2);
            --svg-arc-highlight-fill: rgba(255,128,128,0.4);
            --link-color: #66b2ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 20px;
            padding-bottom: 20px;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 800px;
            width: 90%;
            margin: 20px auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transition: background-color 0.3s;
        }
        h1, h2 {
            color: var(--header-color);
            text-align: center;
            margin-bottom: 20px;
        }
        h3.explanation-subtitle {
            color: var(--explanation-subtitle-color);
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--section-border);
            padding-bottom: 5px;
        }
        .explanation, .quiz, .feedback-section, .selection-menu {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid var(--section-border);
            border-radius: 8px;
            background-color: var(--section-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .triangle-container-wrapper, #triangle-diagram {
            text-align: center;
            margin-bottom: 15px;
            background-color: var(--diagram-wrapper-bg);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid var(--diagram-wrapper-border);
            transition: background-color 0.3s, border-color 0.3s;
        }
        svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        input[type="number"] {
            padding: 10px;
            margin-right: 10px;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--input-text);
            border-radius: 6px;
            font-size: 1rem;
            width: calc(50% - 15px);
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }
        button {
            padding: 12px 20px;
            background-color: var(--button-primary-bg);
            color: var(--button-primary-text);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, color 0.3s ease;
            margin-top: 10px;
        }
        button:hover { background-color: var(--button-primary-hover-bg); }
        #toggleExplanationButton, #darkModeToggle {
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            margin-left: 5px;
        }
        #toggleExplanationButton:hover, #darkModeToggle:hover {
            background-color: var(--button-secondary-hover-bg);
        }

        .streak-counter {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: var(--header-color);
            margin-bottom: 15px;
        }
        .streak-counter span {
            color: var(--explanation-subtitle-color);
            font-size: 1.3em;
        }

        .correct { color: var(--feedback-correct-text); background-color: var(--feedback-correct-bg); border: 1px solid var(--feedback-correct-border); padding: 10px; border-radius: 6px; }
        .incorrect { color: var(--feedback-incorrect-text); background-color: var(--feedback-incorrect-bg); border: 1px solid var(--feedback-incorrect-border); padding: 10px; border-radius: 6px; }
        #feedback { margin-top: 15px; font-weight: bold; min-height: 50px; }
        .uitleg-extra {
            display: block;
            margin-top:15px;
            padding:15px;
            background-color: var(--uitleg-extra-bg);
            border: 1px solid var(--uitleg-extra-border);
            border-radius: 6px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        ul { list-style-position: inside; padding-left: 20px; }
        li { margin-bottom: 8px; }
        .explanation ul li { margin-bottom: 10px; }
        .explanation p { margin-bottom: 12px; }

        /* SVG specific styles using CSS variables */
        .triangle-side { stroke: var(--svg-default-stroke); stroke-width: 1.5px; stroke-linecap: round; }
        .triangle-side.highlighted-stroke { stroke: var(--svg-highlight-stroke); stroke-width: 2.5px; }
        
        .vertex-label { font-family: 'Inter', sans-serif; fill: var(--svg-vertex-label-fill); font-weight: bold; }
        /* .vertex-label.highlighted-fill { fill: var(--svg-text-highlight-fill); } */

        .side-label { font-family: 'Inter', sans-serif; fill: var(--svg-side-label-fill); text-anchor: middle; font-size: 12px; }
        .side-label.highlighted-fill { fill: var(--svg-text-highlight-fill); font-weight: bold; }
        
        .angle-label-text { font-family: 'Inter', sans-serif; fill: var(--svg-angle-label-fill); font-weight: normal; font-size: 12px;}
        .angle-label-text.highlighted-fill { fill: var(--svg-text-highlight-fill); font-weight: bold; }

        /* Removed .angle-arc styles as they are no longer drawn */
        /* .angle-arc { fill: var(--svg-arc-fill); stroke: var(--svg-angle-label-fill); stroke-width: 0.5px;}
        .angle-arc.highlighted-fill { fill: var(--svg-arc-highlight-fill); stroke: var(--svg-highlight-stroke); stroke-width: 1px;} */

        .right-angle-symbol { stroke: var(--svg-right-angle-stroke); fill: none; stroke-width: 1.5px;}


        #uitleg-fout-stappen-container .stap-uitleg {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px dashed var(--uitleg-stap-border);
            border-radius: 6px;
            background-color: var(--uitleg-stap-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        #uitleg-fout-stappen-container h5 {
            color: var(--uitleg-stap-header);
            margin-top: 0;
        }
        #uitleg-fout-stappen-container svg {
            border: 1px solid var(--diagram-wrapper-border);
            background-color: var(--container-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }

        .selection-menu h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--header-color);
            font-size: 1.2em;
            text-align: left;
        }
        .selection-menu .checkbox-group { 
            margin-bottom: 10px;
            display: flex; 
            align-items: center;
        }
        .selection-menu label {
            margin-left: 8px;
            font-size: 1em; 
            color: var(--text-color);
            cursor: pointer;
        }
        .selection-menu input[type="checkbox"] {
            transform: scale(1.2); 
            cursor: pointer;
            margin-right: 5px; 
        }
        .button-group {
            text-align: center;
            margin-bottom: 20px;
        }

        @media (max-width: 600px) {
            .container { width: 95%; padding: 15px; }
            input[type="number"] { width: calc(100% - 20px); margin-bottom: 10px; }
            button { width: 100%; margin-top: 5px; }
            #toggleExplanationButton, #darkModeToggle { width: auto; margin: 5px; }
            .button-group button { width: auto; display: inline-block; margin: 5px; }
            h1 { font-size: 1.8rem; }
            h2 { font-size: 1.5rem; }
            .selection-menu h3 { font-size: 1.1em; }
            .selection-menu label { font-size: 0.9em; }
            .side-label { font-size: 10px; }
            .angle-label-text { font-size: 10px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script type="text/javascript" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</head>
<body>
    <div class="container">
        <h1>📐 Sinus, Cosinus, Tangens & Pythagoras Leren</h1>
        <div class="button-group">
            <button id="toggleExplanationButton">Toon Uitleg</button>
            <button id="darkModeToggle">🌙 Dark Mode</button>
        </div>
        <div class="streak-counter">Winnende streak: <span id="streakValue">0</span></div>

        <div class="explanation" style="display: none;">
            <h2>Uitleg: SOL CAL TOA</h2>
            <p>In een <strong>rechthoekige driehoek</strong> kunnen we de sinus, cosinus en tangens gebruiken om de lengte van zijdes of de grootte van hoeken te berekenen. De driehoek heeft één rechte hoek (90°). De zijdes hebben speciale namen ten opzichte van één van de andere (scherpe) hoeken, bijvoorbeeld hoek A:</p>
             <ul>
                 <li><strong>Langste zijde (L):</strong> Altijd de zijde tegenover de rechte hoek. Dit is de langste zijde van de driehoek. (Ook wel hypotenusa genoemd)</li>
                 <li><strong>Overstaande rechthoekszijde (O):</strong> De zijde die tegenover de hoek staat waaruit je kijkt (hoek A in dit geval).</li>
                 <li><strong>Aanliggende rechthoekszijde (A):</strong> De rechthoekszijde die aan de hoek (hoek A) vastzit, maar niet de langste zijde is.</li>
             </ul>
            <div class="triangle-container-wrapper">
                <p>Stel je een rechthoekige driehoek ABC voor, met de rechte hoek bij C. We kijken vanuit hoek A.</p>
                <svg id="explanationTriangleSvg" width="250" height="200"></svg>
                <p>(Dit is een voorbeeld driehoek.)</p>
            </div>
            <p>De basisregels (ezelsbruggetje: <strong>SOL CAL TOA</strong>):</p>
            <ul>
                <li><strong>S</strong>OL: <strong>S</strong>inus (hoek α) = <strong>O</strong>verstaande / <strong>L</strong>angste ($$\sin(\alpha) = \frac{O}{L}$$)</li>
                <li><strong>C</strong>AL: <strong>C</strong>osinus (hoek α) = <strong>A</strong>anliggende / <strong>L</strong>angste ($$\cos(\alpha) = \frac{A}{L}$$)</li>
                <li><strong>T</strong>OA: <strong>T</strong>angens (hoek α) = <strong>O</strong>verstaande / <strong>A</strong>anliggende ($$\tan(\alpha) = \frac{O}{A}$$)</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende ZIJDE?</h3>
            <p>Als je één hoek (niet de rechte hoek) en één zijde weet, kun je een andere zijde berekenen.</p>
            <ol>
                <li><strong>Identificeer de bekende hoek ($\alpha$).</strong></li>
                <li><strong>Identificeer de bekende zijde:</strong> Is het de Overstaande (O), Aanliggende (A), of Langste (L) zijde ten opzichte van de bekende hoek?</li>
                <li><strong>Identificeer de onbekende zijde:</strong> Is dit O, A, of L?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die zowel de bekende zijde, de onbekende zijde, als de bekende hoek bevat.</li>
                <li><strong>Herschrijf de formule</strong> indien nodig om de onbekende zijde te isoleren.</li>
                <li><strong>Vul de bekende waarden in</strong> en reken de onbekende zijde uit.</li>
            </ol>
            <p><strong>Voorbeeld: Een zijde berekenen</strong></p>
            <p>Stel, hoek A = 30°, en de Langste zijde (L) = 10 cm. We willen de Overstaande zijde (O) weten.</p>
            <ul>
                <li>Bekende hoek: $\alpha = 30°$</li>
                <li>Bekende zijde: L = 10 cm</li>
                <li>Onbekende zijde: O = ?</li>
                <li>Formule: We hebben O en L, dus we gebruiken <strong>SOL</strong>: $$\sin(\alpha) = \frac{O}{L}$$</li>
                <li>Herschrijven: Om O te vinden, vermenigvuldigen we beide kanten met L: $$O = L \times \sin(\alpha)$$</li>
                <li>Invullen: $$O = 10 \times \sin(30°) = 10 \times 0.5 = 5 \text{ cm}$$</li>
            </ul>
            <p>Andere vormen:</p>
            <ul>
                <li>Als je O weet en L zoekt met sin: $$L = \frac{O}{\sin(\alpha)}$$</li>
                <li>Als je A weet en L zoekt met cos: $$L = \frac{A}{\cos(\alpha)}$$</li>
                <li>Als je L weet en A zoekt met cos: $$A = L \times \cos(\alpha)$$</li>
                <li>Als je O weet en A zoekt met tan: $$A = \frac{O}{\tan(\alpha)}$$</li>
                <li>Als je A weet en O zoekt met tan: $$O = A \times \tan(\alpha)$$</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende HOEK?</h3>
            <p>Als je twee zijdes van de rechthoekige driehoek weet, kun je een hoek berekenen met de inverse goniometrische functies: $\sin^{-1}$ (arcsinus), $\cos^{-1}$ (arccosinus), of $\tan^{-1}$ (arctangens).</p>
            <ol>
                <li><strong>Identificeer de hoek ($\alpha$) die je wilt berekenen.</strong></li>
                <li><strong>Identificeer de twee bekende zijdes:</strong> Zijn dit O, A, en/of L ten opzichte van de te berekenen hoek?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die deze twee bekende zijdes bevat.</li>
                <li><strong>Bereken de verhouding</strong> van de zijdes (bijv. O/L).</li>
                <li><strong>Gebruik de bijbehorende inverse functie</strong> op je rekenmachine om de hoek te vinden. Zorg dat je rekenmachine op graden (degrees) staat!</li>
            </ol>
            <p><strong>Voorbeeld: Een hoek berekenen</strong></p>
            <p>Stel, de Overstaande zijde (O) = 6 cm, en de Aanliggende zijde (A) = 8 cm. We willen hoek $\alpha$ weten.</p>
            <ul>
                <li>Te berekenen hoek: $\alpha = ?$</li>
                <li>Bekende zijdes: O = 6 cm, A = 8 cm</li>
                <li>Formule: We hebben O en A, dus we gebruiken <strong>TOA</strong>: $$\tan(\alpha) = \frac{O}{A}$$</li>
                <li>Verhouding: $$\tan(\alpha) = \frac{6}{8} = 0.75$$</li>
                <li>Inverse functie: $$\alpha = \tan^{-1}(0.75)$$</li>
                <li>Uitkomst (met rekenmachine): $$\alpha \approx 36.87°$$</li>
            </ul>
             <p>De inverse formules zijn dus:</p>
            <ul>
                <li>$$ \alpha = \sin^{-1}\left(\frac{O}{L}\right) $$</li>
                <li>$$ \alpha = \cos^{-1}\left(\frac{A}{L}\right) $$</li>
                <li>$$ \alpha = \tan^{-1}\left(\frac{O}{A}\right) $$</li>
            </ul>

            <h3 class="explanation-subtitle">De Stelling van Pythagoras</h3>
            <p>De stelling van Pythagoras is een fundamentele relatie in de Euclidische meetkunde tussen de drie zijden van een rechthoekige driehoek. De stelling stelt dat het kwadraat van de lengte van de langste zijde (de hypotenusa, L) gelijk is aan de som van de kwadraten van de lengtes van de twee andere zijden (de rechthoekszijden, O en A).</p>
            <p>De formule is:</p>
            <p>$$ O^2 + A^2 = L^2 $$</p>
            <p>Waarbij:</p>
            <ul>
                <li>$O$ = Overstaande rechthoekszijde</li>
                <li>$A$ = Aanliggende rechthoekszijde</li>
                <li>$L$ = Langste zijde (hypotenusa)</li>
            </ul>
            <p>Je kunt deze stelling gebruiken om een onbekende zijde te berekenen als je de andere twee zijden weet:</p>
            <ul>
                <li>Als je $O$ en $A$ weet, en $L$ zoekt: $$ L = \sqrt{O^2 + A^2} $$</li>
                <li>Als je $L$ en $O$ weet, en $A$ zoekt: $$ A = \sqrt{L^2 - O^2} $$</li>
                <li>Als je $L$ en $A$ weet, en $O$ zoekt: $$ O = \sqrt{L^2 - A^2} $$</li>
            </ul>
            <p><strong>Voorbeeld: Pythagoras</strong></p>
            <p>Stel, de Overstaande zijde (O) = 3 cm, en de Aanliggende zijde (A) = 4 cm. We willen de Langste zijde (L) weten.</p>
            <ul>
                <li>Bekende zijdes: O = 3 cm, A = 4 cm</li>
                <li>Formule: $$ O^2 + A^2 = L^2 $$</li>
                <li>Invullen: $$ 3^2 + 4^2 = L^2 $$</li>
                <li>$$ 9 + 16 = L^2 $$</li>
                <li>$$ 25 = L^2 $$</li>
                <li>$$ L = \sqrt{25} = 5 \text{ cm} $$</li>
            </ul>
        </div>

        <div class="selection-menu">
            <h3>Kies wat je wilt oefenen:</h3>
            <div class="checkbox-group">
                <input type="checkbox" id="selectSinSides" name="questionType" value="sinSides" checked>
                <label for="selectSinSides">Sinus (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectCosSides" name="questionType" value="cosSides" checked>
                <label for="selectCosSides">Cosinus (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectTanSides" name="questionType" value="tanSides" checked>
                <label for="selectTanSides">Tangens (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectAngles" name="questionType" value="angles" checked>
                <label for="selectAngles">Hoeken berekenen (met sin, cos, of tan)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectPythagoras" name="questionType" value="pythagoras" checked>
                <label for="selectPythagoras">Stelling van Pythagoras</label>
            </div>
        </div>

        <div class="quiz">
            <h2>🎓 Overhoring: Tijd om te oefenen!</h2>
            <p id="question">Klik op "Nieuwe Vraag" om te beginnen.</p>
            <div id="triangle-diagram">
                 <svg id="questionTriangleSvg" width="300" height="225"></svg>
            </div>
            <div>
                <label for="answer" id="answerLabel">Antwoord (getal, 1 decimaal): </label>
                <input type="number" id="answer" step="0.1" placeholder="bv. 7.3">
            </div>
            <button onclick="checkAnswer()">Controleer Antwoord</button>
            <button onclick="newQuestion()">Nieuwe Vraag</button>
            <div id="feedback" class="feedback-section"></div>
            <div id="uitleg-fout" class="uitleg-extra" style="display:none;">
                <h4>Uitleg van de oplossing:</h4>
                <p>De gebruikte regel was: <strong id="uitleg-fout-regel"></strong></p>
                <p>De berekening was: <strong id="uitleg-fout-berekening"></strong></p>
                <div id="uitleg-fout-stappen-container" style="margin-top: 15px;">
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionData = {};
        let currentStreak = 0;
        let lastQuestionTypeOnError = null; 

        const questionElement = document.getElementById('question');
        const answerElement = document.getElementById('answer');
        const answerLabelElement = document.getElementById('answerLabel');
        const feedbackElement = document.getElementById('feedback');
        const uitlegFoutElement = document.getElementById('uitleg-fout');
        const uitlegFoutRegel = document.getElementById('uitleg-fout-regel');
        const uitlegFoutBerekening = document.getElementById('uitleg-fout-berekening');
        const uitlegStappenContainer = document.getElementById('uitleg-fout-stappen-container');
        const explanationDiv = document.querySelector('.explanation');
        const toggleExplanationButton = document.getElementById('toggleExplanationButton');
        const darkModeToggleButton = document.getElementById('darkModeToggle');
        const streakValueElement = document.getElementById('streakValue');

        const selectSinSidesCb = document.getElementById('selectSinSides');
        const selectCosSidesCb = document.getElementById('selectCosSides');
        const selectTanSidesCb = document.getElementById('selectTanSides');
        const selectAnglesCb = document.getElementById('selectAngles');
        const selectPythagorasCb = document.getElementById('selectPythagoras'); // New Pythagoras checkbox

        // Dark Mode Logic
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                darkModeToggleButton.textContent = '☀️ Light Mode';
            } else {
                document.body.classList.remove('dark-mode');
                darkModeToggleButton.textContent = '🌙 Dark Mode';
            }
        }

        darkModeToggleButton.addEventListener('click', () => {
            let currentTheme = localStorage.getItem('theme');
            if (document.body.classList.contains('dark-mode')) {
                currentTheme = 'light';
            } else {
                currentTheme = 'dark';
            }
            localStorage.setItem('theme', currentTheme);
            applyTheme(currentTheme);
            // Redraw triangles to apply new SVG colors
            if (explanationDiv.style.display === 'block' && document.getElementById('explanationTriangleSvg').childNodes.length > 0) {
                drawExplanationTriangle();
            }
            // Ensure the quiz triangle is redrawn with the correct display config
            if (document.getElementById('questionTriangleSvg').childNodes.length > 0 && currentQuestionData.full_side_l) {
                redrawCurrentQuestionTriangle();
            }
            // Ensure explanation steps triangles are redrawn
            if (uitlegFoutElement.style.display === 'block' && currentQuestionData.full_side_l) {
                toonUitlegStappen(currentQuestionData);
            }
        });
        
        // Initialize theme based on localStorage or preference
        const preferredTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        applyTheme(preferredTheme);


        function redrawCurrentQuestionTriangle() {
            if (!currentQuestionData || Object.keys(currentQuestionData).length === 0 || !currentQuestionData.sidesDisplayConfig) return;

            drawTriangleGeneric(
                "questionTriangleSvg",
                currentQuestionData.isAngleQuestion || currentQuestionData.type === 'pythagoras' ? null : currentQuestionData.angleA, // Angle is not relevant for Pythagoras geometry
                currentQuestionData.full_side_l,
                currentQuestionData.full_side_o,
                currentQuestionData.full_side_a,
                currentQuestionData.angleLabelForDisplay,
                "L", "O", "A", // baseLabelL, baseLabelO, baseLabelA (these are internal keys, not displayed)
                currentQuestionData.highlightKey, // highlightKey (kan zijde of 'angleA' zijn)
                300, 225, // customWidth, customHeight for question SVG
                currentQuestionData.isAngleQuestion,
                currentQuestionData.sidesDisplayConfig // Use the dynamic config here
            );
        }


        toggleExplanationButton.addEventListener('click', function() {
            if (explanationDiv.style.display === 'none' || explanationDiv.style.display === '') {
                explanationDiv.style.display = 'block';
                toggleExplanationButton.textContent = 'Verberg Uitleg';
                if (document.getElementById('explanationTriangleSvg').childNodes.length === 0) { 
                    drawExplanationTriangle();
                }
            } else {
                explanationDiv.style.display = 'none';
                toggleExplanationButton.textContent = 'Toon Uitleg';
            }
        });

        function updateStreakDisplay() {
            streakValueElement.textContent = currentStreak;
        }

        function toRadians(degrees) { return degrees * (Math.PI / 180); }
        function toDegrees(radians) { return radians * (180 / Math.PI); }

        function drawExplanationTriangle() {
            const angleA_deg = 30;
            const side_a_expl = 10; 
            const side_o_expl = side_a_expl * Math.tan(toRadians(angleA_deg)); 
            const side_l_expl = side_a_expl / Math.cos(toRadians(angleA_deg)); 
            // Voor de uitlegdriehoek tonen we altijd alle zijden met hun labels en waarden.
            const explanationSidesConfig = {
                L: 'value', // Toon Langste zijde met waarde
                O: 'value', // Toon Overstaande zijde met waarde
                A: 'value'  // Toon Aanliggende zijde met waarde
            };
            drawTriangleGeneric(
                "explanationTriangleSvg", 
                angleA_deg, 
                side_l_expl, 
                side_o_expl, 
                side_a_expl, 
                `Hoek A (${angleA_deg.toFixed(0)}°)`, // labelAngleA
                "L", "O", "A", // baseLabelL, O, A (these are internal keys, not displayed)
                null, // highlightKeys
                250, 200, // customWidth, customHeight
                false, // isAngleQuestion
                explanationSidesConfig, // sidesDisplayConfig
                true // showAllVertexLabels voor uitleg
            );
        }

        function drawTriangleGeneric(
            svgIdOrSelection, angleA_deg, // De *waarde* van hoek A, of null als onbekend/niet relevant voor geometrie
            side_l_geom, side_o_geom, side_a_geom, // *Geometrische* lengtes voor tekenen
            angleALabelText, // De tekst voor het label van hoek A (bv "α = 30°" of "α = ?")
            baseLabelL, baseLabelO, baseLabelA, // Basis labels: "L", "O", "A" (these are internal keys, not displayed)
            highlightItemKey = null, // Key van item om te highlighten ('L', 'O', 'A', of 'angleA')
            customWidth = null, customHeight = null,
            isAngleQuestionForArc = false, // Specifiek voor het bepalen of de hoek A arc getekend moet worden
            sidesDisplayConfig = { L: 'value', O: 'value', A: 'value' }, // Hoe zijdes tonen ('value', 'label', 'hidden')
            showAllVertexLabels = false // Voor uitlegdriehoek
        ) {
            const svg = (typeof svgIdOrSelection === 'string') ? d3.select("#" + svgIdOrSelection) : svgIdOrSelection;
            svg.selectAll("*").remove();

            const svgWidth = customWidth || parseFloat(svg.attr("width")) || 300;
            const svgHeight = customHeight || parseFloat(svg.attr("height")) || 225;

            // VERHOOGDE PADDING voor meer ruimte aan de randen
            const PADDING = customWidth ? (customWidth < 200 ? 25 : 50) : 50; 
            const availableWidth = svgWidth - 2 * PADDING;
            const availableHeight = svgHeight - 2 * PADDING;

            let scale;
            // Gebruik de geometrische waarden voor scaling. Als een waarde 0 of null is, gebruik een default.
            const temp_angle_rad_for_scaling = toRadians(angleA_deg !== null && angleA_deg > 0 && angleA_deg < 90 ? angleA_deg : 35); // Default hoek voor scaling als niet gegeven

            let ref_a = side_a_geom;
            let ref_o = side_o_geom;

            // Als zijdes null zijn, bereken ze voor scaling op basis van de andere of default hoek
            if (side_l_geom && side_l_geom > 0) {
                 if (!ref_a || ref_a <= 0) ref_a = side_l_geom * Math.cos(temp_angle_rad_for_scaling);
                 if (!ref_o || ref_o <= 0) ref_o = side_l_geom * Math.sin(temp_angle_rad_for_scaling);
            }
            if ((!ref_a || ref_a <= 0) && ref_o && ref_o > 0) {
                 ref_a = ref_o / Math.tan(temp_angle_rad_for_scaling);
            } else if ((!ref_o || ref_o <= 0) && ref_a && ref_a > 0) {
                 ref_o = ref_a * Math.tan(temp_angle_rad_for_scaling);
            }
            
            // Fallback als beide nog steeds niet goed zijn, zodat er iets getekend wordt
            if (!ref_a || ref_a <= 0) ref_a = 10;
            if (!ref_o || ref_o <= 0) ref_o = 10 * Math.tan(temp_angle_rad_for_scaling);


            const scaleX = ref_a > 0.1 ? availableWidth / ref_a : availableWidth / 10; 
            const scaleY = ref_o > 0.1 ? availableHeight / ref_o : availableHeight / 10; 
            scale = Math.min(scaleX, scaleY);
            // Zorg voor een redelijke minimale en maximale schaal.
            scale = Math.max(customWidth ? 2 : 3, Math.min(scale, customWidth ? (customWidth/10) : 25)); 

            // Werkelijke geschaalde waarden voor tekenen, gebaseerd op de geometrische input
            const actual_angle_rad = toRadians(angleA_deg !== null && angleA_deg > 0 && angleA_deg < 90 ? angleA_deg : 30); // Fallback voor geometrie als angleA_deg null is

            // Recalculate based on the determined actual_angle_rad and existing sides if any
            let final_side_a_geom = side_a_geom;
            let final_side_o_geom = side_o_geom;
            let final_side_l_geom = side_l_geom;

            // Prioritize given values, then derive if needed
            if (final_side_l_geom === null && final_side_o_geom !== null && final_side_a_geom !== null) {
                final_side_l_geom = Math.sqrt(final_side_o_geom**2 + final_side_a_geom**2);
            } else if (final_side_o_geom === null && final_side_l_geom !== null && final_side_a_geom !== null) {
                final_side_o_geom = final_side_l_geom * Math.sin(actual_angle_rad);
            } else if (final_side_a_geom === null && final_side_l_geom !== null && final_side_o_geom !== null) {
                final_side_a_geom = final_side_l_geom * Math.cos(actual_angle_rad);
            } else if (final_side_a_geom === null && final_side_o_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) { // Assume angleA_deg and O known
                final_side_a_geom = final_side_o_geom / Math.tan(actual_angle_rad);
            } else if (final_side_o_geom === null && final_side_a_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) { // Assume angleA_deg and A known
                final_side_o_geom = final_side_a_geom * Math.tan(actual_angle_rad);
            } else if (final_side_l_geom === null && final_side_o_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) { // Assume angleA_deg and O known
                final_side_l_geom = final_side_o_geom / Math.sin(actual_angle_rad);
            } else if (final_side_l_geom === null && final_side_a_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) { // Assume angleA_deg and A known
                final_side_l_geom = final_side_a_geom / Math.cos(actual_angle_rad);
            }

            // Fallback for cases where only angleA_deg is given, or nothing reasonable
            if (final_side_a_geom === null || final_side_a_geom <= 0) {
                final_side_a_geom = 10; // Default base length for drawing
                final_side_o_geom = final_side_a_geom * Math.tan(actual_angle_rad);
                final_side_l_geom = final_side_a_geom / Math.cos(actual_angle_rad);
            } else if (final_side_o_geom === null || final_side_o_geom <= 0) {
                final_side_o_geom = final_side_a_geom * Math.tan(actual_angle_rad);
                final_side_l_geom = final_side_a_geom / Math.cos(actual_angle_rad);
            } else if (final_side_l_geom === null || final_side_l_geom <= 0) {
                 final_side_l_geom = Math.sqrt(final_side_o_geom**2 + final_side_a_geom**2);
            }


            const final_scaled_a = final_side_a_geom * scale; 
            const final_scaled_o = final_side_o_geom * scale;

            const Cx = PADDING; 
            const Cy = svgHeight - PADDING; // Punt C (rechte hoek)
            const Ax = Cx + final_scaled_a; 
            const Ay = Cy;        // Punt A
            const Bx = Cx; 
            const By = Cy - final_scaled_o;       // Punt B
            const group = svg.append("g");

            // Define side names based on vertices
            const sideNames = {
                A: 'AC', // Aanliggende
                O: 'BC', // Overstaande
                L: 'AB'  // Langste
            };

            const rawSidesData = [
                { id: 'AC', x1: Cx, y1: Cy, x2: Ax, y2: Ay, labelKey: sideNames.A, value: final_side_a_geom, key: 'A', name: "Aanliggende", labelPos: {x: (Cx+Ax)/2, y: Ay + 15} },
                { id: 'BC', x1: Cx, y1: Cy, x2: Bx, y2: By, labelKey: sideNames.O, value: final_side_o_geom, key: 'O', name: "Overstaande", labelPos: {x: Bx - 20, y: (Cy+By)/2} },
                { id: 'AB', x1: Ax, y1: Ay, x2: Bx, y2: By, labelKey: sideNames.L, value: final_side_l_geom, key: 'L', name: "Langste", labelPos: {x: (Ax+Bx)/2 + 5, y: (Ay+By)/2 - 5} }
            ];

            // Filter out sides marked as 'hidden' before drawing lines or labels
            const visibleSidesData = rawSidesData.filter(d => sidesDisplayConfig[d.key] !== 'hidden');

            // Draw sides
            group.selectAll(".triangle-side")
                .data(visibleSidesData)
                .enter().append("line")
                .attr("x1", d => d.x1)
                .attr("y1", d => d.y1)
                .attr("x2", d => d.x2)
                .attr("y2", d => d.y2)
                .attr("class", d => `triangle-side ${highlightItemKey === d.key ? 'highlighted-stroke' : ''}`);

            // Draw side labels
            group.selectAll(".side-label")
                .data(visibleSidesData)
                .enter().append("text")
                .attr("x", d => d.labelPos.x)
                .attr("y", d => d.labelPos.y)
                .attr("class", d => `side-label ${highlightItemKey === d.key ? 'highlighted-fill' : ''}`)
                .text(d => {
                    // Display value if 'value' is specified in sidesDisplayConfig
                    if (sidesDisplayConfig[d.key] === 'value') {
                        return `${d.labelKey} = ${d.value.toFixed(1)}`;
                    } 
                    // Always display label (vertex name) if not hidden
                    else if (sidesDisplayConfig[d.key] === 'label') {
                        return d.labelKey;
                    }
                    return ''; // Should not happen due to filter, but as fallback
                });

            // Vertices labels
            const vertices = [
                { id: 'A', x: Ax, y: Ay, label: 'A' },
                { id: 'B', x: Bx, y: By, label: 'B' },
                { id: 'C', x: Cx, y: Cy, label: 'C' }
            ];

            group.selectAll(".vertex-label")
                .data(vertices)
                .enter().append("text")
                .attr("x", d => d.x + (d.id === 'A' ? 5 : d.id === 'B' ? -15 : -15))
                .attr("y", d => d.y + (d.id === 'A' ? 15 : d.id === 'B' ? -5 : 15))
                .attr("class", "vertex-label")
                .text(d => d.label);
            
            // Re-introducing the angle A drawing logic, but WITHOUT the arc path
            if ((angleA_deg !== null && !isAngleQuestionForArc) || (isAngleQuestionForArc && highlightItemKey !== 'angleA')) {
                const labelOffsetRadius = 30; // Offset for label from vertex A
                
                // Calculate angle for the bisector of angle A
                const bisectorAngleRad = actual_angle_rad / 2;

                const angleData = {
                    x: Ax,
                    y: Ay,
                    // Position label along the bisector of the angle, slightly outside the vertex
                    labelX: Ax + labelOffsetRadius * Math.cos(bisectorAngleRad),
                    labelY: Ay - labelOffsetRadius * Math.sin(bisectorAngleRad), // Subtract for SVG y-axis
                    labelText: angleALabelText,
                    key: 'angleA'
                };

                // Removed: group.append("path") for the arc
                
                group.append("text")
                    .attr("x", angleData.labelX)
                    .attr("y", angleData.labelY)
                    .attr("class", `angle-label-text ${highlightItemKey === angleData.key ? 'highlighted-fill' : ''}`)
                    .text(angleALabelText)
                    .style("text-anchor", "middle");
            } else if (isAngleQuestionForArc && highlightItemKey === 'angleA') {
                 // If angle A is the unknown, draw a question mark
                const labelOffsetRadius = 30; // Consistent offset for label
                
                // Use a default angle for positioning the '?'
                const defaultAngleRad = toRadians(30); 
                const bisectorAngleRad = defaultAngleRad / 2;

                group.append("text")
                    .attr("x", Ax + labelOffsetRadius * Math.cos(bisectorAngleRad))
                    .attr("y", Ay - labelOffsetRadius * Math.sin(bisectorAngleRad))
                    .attr("class", `angle-label-text highlighted-fill`) // Highlight the '?'
                    .text("?")
                    .style("text-anchor", "middle");

                // Removed: group.append("path") for the arc
            }


            // Right angle at C
            const rightAngleSize = 10;
            group.append("path")
                .attr("d", `M ${Cx + rightAngleSize},${Cy} L ${Cx + rightAngleSize},${Cy - rightAngleSize} L ${Cx},${Cy - rightAngleSize}`)
                .attr("class", "right-angle-symbol");
        }

        function generateQuestion() {
            const selectedTypes = Array.from(document.querySelectorAll('.selection-menu input[name="questionType"]:checked')).map(cb => cb.value);
            if (selectedTypes.length === 0) {
                questionElement.innerHTML = "Selecteer minimaal één type vraag om te beginnen.";
                answerElement.value = "";
                feedbackElement.className = 'feedback-section';
                feedbackElement.textContent = "";
                uitlegFoutElement.style.display = 'none';
                drawTriangleGeneric("questionTriangleSvg", null, null, null, null, "", "L", "O", "A", null, 300, 225, false, { L: 'label', O: 'label', A: 'label' });
                return;
            }

            const questionType = selectedTypes[Math.floor(Math.random() * selectedTypes.length)];
            let angleA, sideA, sideO, sideL;
            let questionText = "";
            let correctAnswer;
            let highlightKey = null;
            let sidesDisplayConfig = { L: 'label', O: 'label', A: 'label' }; // Default, will be overridden
            let angleLabelText = `Hoek A = ?`;
            let isAngleQuestion = false;

            const minAngle = 20;
            const maxAngle = 70;
            const minSide = 5;
            const maxSide = 20;

            // Define side names based on vertices for question text and diagram
            const sideNames = {
                A: 'AC', // Aanliggende
                O: 'BC', // Overstaande
                L: 'AB'  // Langste
            };

            // Generate robust random numbers for triangle sides/angles
            if (questionType !== 'pythagoras') {
                angleA = Math.random() * (maxAngle - minAngle) + minAngle;
                angleA = parseFloat(angleA.toFixed(1)); 

                const baseSideVal = Math.random() * (maxSide - minSide) + minSide;
                sideA = parseFloat(baseSideVal.toFixed(1));
                sideO = parseFloat((sideA * Math.tan(toRadians(angleA))).toFixed(1));
                sideL = parseFloat((sideA / Math.cos(toRadians(angleA))).toFixed(1));

                if (sideO < minSide || sideL < minSide || sideO > maxSide * 2 || sideL > maxSide * 2 || isNaN(sideO) || isNaN(sideL)) {
                    return generateQuestion();
                }
            } else { // Pythagoras questions
                const pythSides = [
                    { O: 3, A: 4, L: 5 },
                    { O: 6, A: 8, L: 10 },
                    { O: 5, A: 12, L: 13 },
                    { O: 8, A: 15, L: 17 },
                    { O: 7, A: 24, L: 25 }
                ];
                const chosenPythSet = pythSides[Math.floor(Math.random() * pythSides.length)];
                sideO = chosenPythSet.O;
                sideA = chosenPythSet.A;
                sideL = chosenPythSet.L;
                angleA = toDegrees(Math.atan(sideO / sideA)); 
            }


            let known1, known2, unknown;
            let formulaText = "";
            let calculationSteps = [];
            let solveMethod = "";


            switch (questionType) {
                case 'sinSides':
                    angleLabelText = `Hoek A = ${angleA}°`;
                    if (Math.random() < 0.5) { // Calculate O (side BC)
                        unknown = 'O';
                        correctAnswer = sideO;
                        questionText = `Gegeven Hoek A = ${angleA}° en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>zijde ${sideNames.O}</b>.`;
                        formulaText = `$$\\sin(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{L}}$$`;
                        solveMethod = `$$O = L \\times \\sin(\\text{Hoek A})$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'label' }; // L known, O unknown, A also shown
                        highlightKey = 'O';
                    } else { // Calculate L (side AB)
                        unknown = 'L';
                        correctAnswer = sideL;
                        questionText = `Gegeven Hoek A = ${angleA}° en zijde ${sideNames.O} = ${sideO} cm.<br>Bereken <b>zijde ${sideNames.L}</b>.`;
                        formulaText = `$$\\sin(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{L}}$$`;
                        solveMethod = `$$L = \\frac{\\text{O}}{\\sin(\\text{Hoek A})}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'label' }; // O known, L unknown, A also shown
                        highlightKey = 'L';
                    }
                    break;

                case 'cosSides':
                    angleLabelText = `Hoek A = ${angleA}°`;
                    if (Math.random() < 0.5) { // Calculate A (side AC)
                        unknown = 'A';
                        correctAnswer = sideA;
                        questionText = `Gegeven Hoek A = ${angleA}° en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>zijde ${sideNames.A}</b>.`;
                        formulaText = `$$\\cos(\\text{Hoek A}) = \\frac{\\text{A}}{\\text{L}}$$`;
                        solveMethod = `$$A = L \\times \\cos(\\text{Hoek A})$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'label' }; // L known, A unknown, O also shown
                        highlightKey = 'A';
                    } else { // Calculate L (side AB)
                        unknown = 'L';
                        correctAnswer = sideL;
                        questionText = `Gegeven Hoek A = ${angleA}° en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.L}</b>.`;
                        formulaText = `$$\\cos(\\text{Hoek A}) = \\frac{\\text{A}}{\\text{L}}$$`;
                        solveMethod = `$$L = \\frac{\\text{A}}{\\cos(\\text{Hoek A})}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'label', A: 'value' }; // A known, L unknown, O also shown
                        highlightKey = 'L';
                    }
                    break;

                case 'tanSides':
                    angleLabelText = `Hoek A = ${angleA}°`;
                    if (Math.random() < 0.5) { // Calculate O (side BC)
                        unknown = 'O';
                        correctAnswer = sideO;
                        questionText = `Gegeven Hoek A = ${angleA}° en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.O}</b>.`;
                        formulaText = `$$\\tan(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{A}}$$`;
                        solveMethod = `$$O = A \\times \\tan(\\text{Hoek A})$$`;
                        sidesDisplayConfig = { L: 'label', O: 'label', A: 'value' }; // A known, O unknown, L also shown
                        highlightKey = 'O';
                    } else { // Calculate A (side AC)
                        unknown = 'A';
                        correctAnswer = sideA;
                        questionText = `Gegeven Hoek A = ${angleA}° en zijde ${sideNames.O} = ${sideO} cm.<br>Bereken <b>zijde ${sideNames.A}</b>.`;
                        formulaText = `$$\\tan(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{A}}$$`;
                        solveMethod = `$$A = \\frac{\\text{O}}{\\tan(\\text{Hoek A})}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'label' }; // O known, A unknown, L also shown
                        highlightKey = 'A';
                    }
                    break;

                case 'angles':
                    isAngleQuestion = true;
                    angleLabelText = `Hoek A = ?`; // Angle is unknown
                    const angleChoice = Math.floor(Math.random() * 3); // 0: Sin, 1: Cos, 2: Tan

                    if (angleChoice === 0) { // Calculate angle A using Sine (O and L known)
                        unknown = 'angleA';
                        correctAnswer = angleA;
                        questionText = `Gegeven zijde ${sideNames.O} = ${sideO} cm en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>Hoek A</b>.`;
                        formulaText = `$$\\sin(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{L}}$$`;
                        solveMethod = `$$\\text{Hoek A} = \\sin^{-1}\\left(\\frac{\\text{O}}{\\text{L}}\\right)$$`;
                        sidesDisplayConfig = { L: 'value', O: 'value', A: 'label' }; // O and L known, A also shown
                        highlightKey = 'angleA';
                    } else if (angleChoice === 1) { // Calculate angle A using Cosine (A and L known)
                        unknown = 'angleA';
                        correctAnswer = angleA;
                        questionText = `Gegeven zijde ${sideNames.A} = ${sideA} cm en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>Hoek A</b>.`;
                        formulaText = `$$\\cos(\\text{Hoek A}) = \\frac{\\text{A}}{\\text{L}}$$`;
                        solveMethod = `$$\\text{Hoek A} = \\cos^{-1}\\left(\\frac{\\text{A}}{\\text{L}}\\right)$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'value' }; // A and L known, O also shown
                        highlightKey = 'angleA';
                    } else { // Calculate angle A using Tangent (O and A known)
                        unknown = 'angleA';
                        correctAnswer = angleA;
                        questionText = `Gegeven zijde ${sideNames.O} = ${sideO} cm en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>Hoek A</b>.`;
                        formulaText = `$$\\tan(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{A}}$$`;
                        solveMethod = `$$\\text{Hoek A} = \\tan^{-1}\\left(\\frac{\\text{O}}{\\text{A}}\\right)$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'value' }; // O and A known, L also shown
                        highlightKey = 'angleA';
                    }
                    break;
                
                case 'pythagoras':
                    isAngleQuestion = false; // Pythagoras questions don't involve angles in the calculation
                    angleLabelText = ''; // No angle label for Pythagoras questions
                    const unknownPythSide = ['O', 'A', 'L'][Math.floor(Math.random() * 3)];

                    if (unknownPythSide === 'L') {
                        unknown = 'L';
                        correctAnswer = sideL;
                        questionText = `Gegeven zijde ${sideNames.O} = ${sideO} cm en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.L}</b> met Pythagoras.`;
                        formulaText = `$$O^2 + A^2 = L^2$$`;
                        solveMethod = `$$L = \\sqrt{O^2 + A^2}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'value' }; // O and A known, L unknown
                        highlightKey = 'L';
                    } else if (unknownPythSide === 'O') {
                        unknown = 'O';
                        correctAnswer = sideO;
                        questionText = `Gegeven zijde ${sideNames.L} = ${sideL} cm en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.O}</b> met Pythagoras.`;
                        formulaText = `$$O^2 + A^2 = L^2$$`;
                        solveMethod = `$$O = \\sqrt{L^2 - A^2}$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'value' }; // L and A known, O unknown
                        highlightKey = 'O';
                    } else { // unknownPythSide === 'A'
                        unknown = 'A';
                        correctAnswer = sideA;
                        questionText = `Gegeven zijde ${sideNames.L} = ${sideL} cm en zijde ${sideNames.O} = ${sideO} cm.<br>Bereken <b>zijde ${sideNames.A}</b> met Pythagoras.`;
                        formulaText = `$$O^2 + A^2 = L^2$$`;
                        solveMethod = `$$A = \\sqrt{L^2 - O^2}$$`;
                        sidesDisplayConfig = { L: 'value', O: 'value', A: 'label' }; // L and O known, A unknown
                        highlightKey = 'A';
                    }
                    break;
                default:
                    questionText = "Selecteer een vraagtype en klik op 'Nieuwe Vraag'.";
                    correctAnswer = 0;
            }
            
            currentQuestionData = {
                type: questionType,
                angleA: angleA,
                sideA: sideA,
                sideO: sideO,
                sideL: sideL,
                full_side_a: sideA, // Store full calculated sides for drawing and explanation
                full_side_o: sideO,
                full_side_l: sideL,
                correctAnswer: parseFloat(correctAnswer.toFixed(1)),
                questionText: questionText,
                unknown: unknown,
                formulaText: formulaText,
                solveMethod: solveMethod,
                calculationSteps: [], // Initialize empty, populate below
                highlightKey: highlightKey,
                sidesDisplayConfig: sidesDisplayConfig, // Use the dynamically set config for the main question
                angleLabelForDisplay: angleLabelText,
                isAngleQuestion: isAngleQuestion,
                sideNames: sideNames // Pass sideNames to be used in explanation steps
            };

            // Populate calculationSteps based on the chosen question type and unknown side
            // This ensures the explanation steps have the correct side display logic
            if (questionType === 'sinSides' || questionType === 'cosSides' || questionType === 'tanSides') {
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: (unknown === 'O' || unknown === 'L') ? 'L' : ((unknown === 'A' || unknown === 'L') ? 'A' : 'O'), // Highlight a known side
                    isAngleQuestion: false,
                    sidesDisplayConfig: { // Show known angle and one known side
                        L: (unknown === 'L' || unknown === 'O') ? 'value' : 'label', 
                        O: (unknown === 'O' || unknown === 'L') ? 'label' : 'value',
                        A: (unknown === 'A' || unknown === 'L') ? 'value' : 'label'
                    },
                    stepText: `We kennen Hoek A = ${angleA}° en zijde ${sideNames[Object.keys(currentQuestionData.sidesDisplayConfig).find(k => currentQuestionData.sidesDisplayConfig[k] === 'value')] || ''} = ${currentQuestionData[`full_side_${Object.keys(currentQuestionData.sidesDisplayConfig).find(k => currentQuestionData.sidesDisplayConfig[k] === 'value')}`]} cm. We zoeken zijde ${sideNames[unknown]}.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: unknown, // Highlight the unknown side
                    isAngleQuestion: false,
                    sidesDisplayConfig: sidesDisplayConfig, // Show known values and unknown label
                    stepText: `De formule is ${formulaText}. Om ${sideNames[unknown]} te vinden, herschikken we naar ${solveMethod}.`
                });
            } else if (questionType === 'angles') {
                const knownSide1Key = Object.keys(sidesDisplayConfig).find(k => sidesDisplayConfig[k] === 'value');
                const knownSide2Key = Object.keys(sidesDisplayConfig).filter(k => sidesDisplayConfig[k] === 'value')[1];

                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: knownSide1Key, // Highlight one of the known sides
                    isAngleQuestion: true,
                    sidesDisplayConfig: { // Show both known sides
                        L: sidesDisplayConfig['L'],
                        O: sidesDisplayConfig['O'],
                        A: sidesDisplayConfig['A']
                    },
                    stepText: `We kennen zijde ${sideNames[knownSide1Key]} = ${currentQuestionData[`full_side_${knownSide1Key}`]} cm en zijde ${sideNames[knownSide2Key]} = ${currentQuestionData[`full_side_${knownSide2Key}`]} cm. We zoeken Hoek A.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: 'angleA', // Highlight the unknown angle
                    isAngleQuestion: true,
                    sidesDisplayConfig: sidesDisplayConfig, // Show known values and unknown label
                    stepText: `De formule is ${formulaText}. Om Hoek A te vinden, gebruiken we de inverse functie: ${solveMethod}.`
                });
            } else if (questionType === 'pythagoras') {
                let knownSide1 = '';
                let knownSide2 = '';
                if (unknown === 'L') {
                    knownSide1 = 'O';
                    knownSide2 = 'A';
                } else if (unknown === 'O') {
                    knownSide1 = 'L';
                    knownSide2 = 'A';
                } else { // unknown === 'A'
                    knownSide1 = 'L';
                    knownSide2 = 'O';
                }

                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: knownSide1, isAngleQuestion: false,
                    sidesDisplayConfig: { // Show first known side
                        L: knownSide1 === 'L' ? 'value' : 'label',
                        O: knownSide1 === 'O' ? 'value' : 'label',
                        A: knownSide1 === 'A' ? 'value' : 'label'
                    },
                    stepText: `We kennen zijde ${sideNames[knownSide1]} = ${currentQuestionData[`full_side_${knownSide1}`]} cm. We zoeken zijde ${sideNames[unknown]}.`
                });
                 currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: knownSide2, isAngleQuestion: false,
                    sidesDisplayConfig: { // Show both known sides
                        L: (knownSide1 === 'L' || knownSide2 === 'L') ? 'value' : 'label',
                        O: (knownSide1 === 'O' || knownSide2 === 'O') ? 'value' : 'label',
                        A: (knownSide1 === 'A' || knownSide2 === 'A') ? 'value' : 'label'
                    },
                    stepText: `We kennen ook zijde ${sideNames[knownSide2]} = ${currentQuestionData[`full_side_${knownSide2}`]} cm. De stelling van Pythagoras is $O^2 + A^2 = L^2$.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg',
                    angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText,
                    highlightKey: unknown, isAngleQuestion: false,
                    sidesDisplayConfig: sidesDisplayConfig, // Show known values and unknown label
                    stepText: `Om ${sideNames[unknown]} te vinden, herschikken we naar ${solveMethod}.`
                });
            }


            questionElement.innerHTML = currentQuestionData.questionText;
            answerLabelElement.textContent = `Antwoord (${unknown === 'angleA' ? 'graden' : 'cm'}, 1 decimaal): `;
            answerElement.value = "";
            feedbackElement.className = 'feedback-section';
            feedbackElement.textContent = "";
            uitlegFoutElement.style.display = 'none';

            // Draw the initial question triangle
            drawTriangleGeneric(
                "questionTriangleSvg",
                isAngleQuestion || questionType === 'pythagoras' ? null : angleA, // Pass null for angle if it's the unknown or a Pythagoras question
                sideL, sideO, sideA, // Geometric values for drawing
                angleLabelText, // Label for angle A
                "L", "O", "A", // Base labels (internal keys)
                highlightKey, // Item to highlight
                300, 225, // Custom size
                isAngleQuestion, // Pass true if it's an angle question
                currentQuestionData.sidesDisplayConfig // Use the dynamic config here
            );

            // Re-render MathJax
            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {
                    // console.log('MathJax typeset complete after new question.');
                });
            }
        }

        function checkAnswer() {
            const userAnswer = parseFloat(answerElement.value);
            if (isNaN(userAnswer)) {
                feedbackElement.className = 'feedback-section incorrect';
                feedbackElement.textContent = "Voer een geldig getal in.";
                uitlegFoutElement.style.display = 'none';
                currentStreak = 0;
                updateStreakDisplay();
                return;
            }

            const correctAnswer = currentQuestionData.correctAnswer;
            const tolerance = 0.1; // Allow for rounding differences

            if (Math.abs(userAnswer - correctAnswer) <= tolerance) {
                feedbackElement.className = 'feedback-section correct';
                feedbackElement.textContent = `Correct! Het antwoord is ${correctAnswer.toFixed(1)}.`;
                uitlegFoutElement.style.display = 'none';
                currentStreak++;
                updateStreakDisplay();
                newQuestion(); // Automatically generate a new question on correct answer
            } else {
                feedbackElement.className = 'feedback-section incorrect';
                feedbackElement.textContent = `Niet helemaal correct. Jouw antwoord: ${userAnswer.toFixed(1)}. Het juiste antwoord is ${correctAnswer.toFixed(1)}.`;
                currentStreak = 0;
                updateStreakDisplay();
                uitlegFoutElement.style.display = 'block';
                toonUitlegStappen(currentQuestionData);
            }

            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function toonUitlegStappen(data) {
            uitlegFoutRegel.innerHTML = data.formulaText;
            uitlegFoutBerekening.innerHTML = data.solveMethod;
            uitlegStappenContainer.innerHTML = ''; // Clear previous steps

            data.calculationSteps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'stap-uitleg';
                stepDiv.innerHTML = `<h5>Stap ${index + 1}</h5><p>${step.stepText}</p><svg id="uitlegStepSvg${index}" width="250" height="200"></svg>`;
                uitlegStappenContainer.appendChild(stepDiv);

                // Draw triangle for this step with specific highlights and side display config
                drawTriangleGeneric(
                    `uitlegStepSvg${index}`,
                    step.isAngleQuestion || data.type === 'pythagoras' ? null : step.angleA, 
                    step.full_side_l,
                    step.full_side_o,
                    step.full_side_a,
                    step.angleLabelForDisplay,
                    "L", "O", "A", // Base labels (internal keys)
                    step.highlightKey,
                    250, 200, 
                    step.isAngleQuestion,
                    step.sidesDisplayConfig // Use the specific config for this step
                );
            });

            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function newQuestion() {
            generateQuestion();
            answerElement.focus();
        }

        // Event listeners for checkboxes to ensure at least one is selected
        const checkboxes = document.querySelectorAll('.selection-menu input[name="questionType"]');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const checkedCount = document.querySelectorAll('.selection-menu input[name="questionType"]:checked').length;
                if (checkedCount === 0) {
                    checkbox.checked = true;
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background-color: var(--container-bg);
                        color: var(--text-color);
                        padding: 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                        z-index: 1000;
                        text-align: center;
                    `;
                    messageBox.innerHTML = `
                        <p>Minimaal één vraagtype moet geselecteerd zijn.</p>
                        <button onclick="this.parentNode.remove()" style="margin-top: 10px; padding: 8px 15px; background-color: var(--button-primary-bg); color: var(--button-primary-text); border: none; border-radius: 4px; cursor: pointer;">OK</button>
                    `;
                    document.body.appendChild(messageBox);
                }
            });
        });

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            newQuestion(); // Generate first question on page load
        });
    </script>
</body>
</html>
