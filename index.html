<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leren over Sinus, Cosinus, Tangens & Pythagoras (D3.js, Dark Mode)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f9ff;
            --text-color: #333;
            --container-bg: #ffffff;
            --header-color: #005A9C;
            --explanation-subtitle-color: #007bff;
            --section-bg: #e7f5ff;
            --section-border: #bde0fe;
            --diagram-wrapper-bg: #f8f9fa;
            --diagram-wrapper-border: #dee2e6;
            --input-bg: #fff;
            --input-text: #333;
            --input-border: #ced4da;
            --button-primary-bg: #007bff;
            --button-primary-text: white;
            --button-primary-hover-bg: #0056b3;
            --button-secondary-bg: #6c757d;
            --button-secondary-text: white;
            --button-secondary-hover-bg: #5a6268;
            --feedback-correct-text: #155724;
            --feedback-correct-bg: #d4edda;
            --feedback-correct-border: #c3e6cb;
            --feedback-incorrect-text: #721c24;
            --feedback-incorrect-bg: #f8d7da;
            --feedback-incorrect-border: #f5c6cb;
            --uitleg-extra-bg: #fff3cd;
            --uitleg-extra-border: #ffeeba;
            --uitleg-stap-bg: #e7f5ff;
            --uitleg-stap-border: #007bff;
            --uitleg-stap-header: #005A9C;
            --svg-default-stroke: #333;
            --svg-highlight-stroke: #d9534f; /* Rood voor highlight */
            --svg-text-highlight-fill: #d9534f; /* Rood voor highlight tekst */
            --svg-vertex-label-fill: #005A9C;
            --svg-side-label-fill: #007bff;
            --svg-angle-label-fill: red;
            --svg-right-angle-stroke: #555;
            --link-color: #007bff;

            /* Mode specific styles */
            --mode-bg: #e0e0e0;
            --mode-border: #a0a0a0;
            --numpad-bg: #f0f0f0;
            --numpad-button-bg: #ffffff;
            --numpad-button-hover-bg: #e0e0e0;
            --numpad-button-text: #333;
            --active-input-border: #007bff;
            --active-input-bg: #e7f5ff;
            --answer-display-bg: #f0f0f0;
            --answer-display-border: #ccc;
        }

        body.dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --container-bg: #2c2c2c;
            --header-color: #66b2ff;
            --explanation-subtitle-color: #80c7ff;
            --section-bg: #383838;
            --section-border: #555555;
            --diagram-wrapper-bg: #222222;
            --diagram-wrapper-border: #4a4a4a;
            --input-bg: #3e3e3e;
            --input-text: #e0e0e0;
            --input-border: #666666;
            --button-primary-bg: #66b2ff;
            --button-primary-text: #1a1a1a;
            --button-primary-hover-bg: #80c7ff;
            --button-secondary-bg: #5a6268;
            --button-secondary-text: #e0e0e0;
            --button-secondary-hover-bg: #707880;
            --feedback-correct-text: #a7f0ba;
            --feedback-correct-bg: #223e2b;
            --feedback-correct-border: #355e40;
            --feedback-incorrect-text: #f5b9c0;
            --feedback-incorrect-bg: #4a2328;
            --feedback-incorrect-border: #70363d;
            --uitleg-extra-bg: #4d432c;
            --uitleg-extra-border: #806f44;
            --uitleg-stap-bg: #383838;
            --uitleg-stap-border: #66b2ff;
            --uitleg-stap-header: #66b2ff;
            --svg-default-stroke: #c9d1d9;
            --svg-highlight-stroke: #ff8c82; /* Lichter rood/oranje voor dark mode highlight */
            --svg-text-highlight-fill: #ff8c82;
            --svg-vertex-label-fill: #66b2ff;
            --svg-side-label-fill: #80c7ff;
            --svg-angle-label-fill: #ff8080; /* Lichter rood voor dark mode hoek */
            --svg-right-angle-stroke: #888888;
            --link-color: #66b2ff;

            /* Mode specific styles - Dark Mode */
            --mode-bg: #333333;
            --mode-border: #555555;
            --numpad-bg: #444444;
            --numpad-button-bg: #555555;
            --numpad-button-hover-bg: #666666;
            --numpad-button-text: #e0e0e0;
            --active-input-border: #80c7ff;
            --active-input-bg: #383838;
            --answer-display-bg: #3e3e3e;
            --answer-display-border: #666;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 20px;
            padding-bottom: 20px;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 800px;
            width: 90%;
            margin: 20px auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transition: background-color 0.3s;
        }
        h1, h2 {
            color: var(--header-color);
            text-align: center;
            margin-bottom: 20px;
        }
        h3.explanation-subtitle {
            color: var(--explanation-subtitle-color);
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--section-border);
            padding-bottom: 5px;
        }
        .explanation, .quiz-section, .digibord-section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid var(--section-border);
            border-radius: 8px;
            background-color: var(--section-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .triangle-container-wrapper, .diagram-area {
            text-align: center;
            margin-bottom: 15px;
            background-color: var(--diagram-wrapper-bg);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid var(--diagram-wrapper-border);
            transition: background-color 0.3s, border-color 0.3s;
        }
        svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        button {
            padding: 12px 20px;
            background-color: var(--button-primary-bg);
            color: var(--button-primary-text);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, color 0.3s ease;
            margin-top: 10px;
        }
        button:hover { background-color: var(--button-primary-hover-bg); }
        #toggleExplanationButton, #darkModeToggle, #toggleQuizMode, #toggleDigibordMode {
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            margin-left: 5px;
        }
        #toggleExplanationButton:hover, #darkModeToggle:hover, #toggleQuizMode:hover, #toggleDigibordMode:hover {
            background-color: var(--button-secondary-hover-bg);
        }

        .streak-counter {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: var(--header-color);
            margin-bottom: 15px;
        }
        .streak-counter span {
            color: var(--explanation-subtitle-color);
            font-size: 1.3em;
        }

        .feedback-message {
            margin-top: 15px;
            font-weight: bold;
            min-height: 50px;
            padding: 10px;
            border-radius: 6px;
        }
        .feedback-message.correct { color: var(--feedback-correct-text); background-color: var(--feedback-correct-bg); border: 1px solid var(--feedback-correct-border); }
        .feedback-message.incorrect { color: var(--feedback-incorrect-text); background-color: var(--feedback-incorrect-bg); border: 1px solid var(--feedback-incorrect-border); }
        
        .uitleg-extra {
            display: block;
            margin-top:15px;
            padding:15px;
            background-color: var(--uitleg-extra-bg);
            border: 1px solid var(--uitleg-extra-border);
            border-radius: 6px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        ul { list-style-position: inside; padding-left: 20px; }
        li { margin-bottom: 8px; }
        .explanation ul li { margin-bottom: 10px; }
        .explanation p { margin-bottom: 12px; }

        /* SVG specific styles using CSS variables */
        .triangle-side { stroke: var(--svg-default-stroke); stroke-width: 1.5px; stroke-linecap: round; }
        .triangle-side.highlighted-stroke { stroke: var(--svg-highlight-stroke); stroke-width: 2.5px; }
        
        .vertex-label { font-family: 'Inter', sans-serif; fill: var(--svg-vertex-label-fill); font-weight: bold; }

        .side-label { font-family: 'Inter', sans-serif; fill: var(--svg-side-label-fill); text-anchor: middle; font-size: 12px; cursor: pointer; }
        .side-label.highlighted-fill { fill: var(--svg-text-highlight-fill); font-weight: bold; }
        .side-label.active-input { stroke: var(--active-input-border); stroke-width: 1px; fill: var(--active-input-bg); } /* Highlight active input in digibord */
        
        .angle-label-text { font-family: 'Inter', sans-serif; fill: var(--svg-angle-label-fill); font-weight: normal; font-size: 12px; cursor: pointer;}
        .angle-label-text.highlighted-fill { fill: var(--svg-text-highlight-fill); font-weight: bold; }
        .angle-label-text.active-input { stroke: var(--active-input-border); stroke-width: 1px; fill: var(--active-input-bg); } /* Highlight active input in digibord */

        .right-angle-symbol { stroke: var(--svg-right-angle-stroke); fill: none; stroke-width: 1.5px;}


        #uitleg-fout-stappen-container .stap-uitleg {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px dashed var(--uitleg-stap-border);
            border-radius: 6px;
            background-color: var(--uitleg-stap-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        #uitleg-fout-stappen-container h5 {
            color: var(--uitleg-stap-header);
            margin-top: 0;
        }
        #uitleg-fout-stappen-container svg {
            border: 1px solid var(--diagram-wrapper-border);
            background-color: var(--container-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }

        .main-button-group {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .main-button-group button {
            margin-top: 0; /* Override default button margin */
        }

        /* Quiz Mode Styles */
        .quiz-mode-wrapper {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 25px;
            padding: 20px;
            border: 1px solid var(--mode-border);
            border-radius: 8px;
            background-color: var(--mode-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }

        .quiz-content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        .quiz-content-area .diagram-area {
            width: 100%;
            max-width: 450px;
            height: 300px;
        }

        .quiz-input-area {
            width: 100%;
            max-width: 450px;
            margin-top: 15px;
            text-align: center;
        }
        .quiz-input-area #quizAnswerDisplay {
            min-height: 40px;
            line-height: 40px;
            background-color: var(--answer-display-bg);
            border: 1px solid var(--answer-display-border);
            border-radius: 6px;
            font-size: 1.2em;
            font-weight: bold;
            padding: 0 10px;
            text-align: center;
            margin-bottom: 10px;
            color: var(--input-text);
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }
        .quiz-input-area .quiz-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        .quiz-input-area .quiz-buttons button {
            flex-grow: 1;
            max-width: 200px;
        }


        /* Digibord Mode Styles (similar to quiz-mode-wrapper, but for digibord) */
        .digibord-mode-wrapper {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 25px;
            padding: 20px;
            border: 1px solid var(--mode-border);
            border-radius: 8px;
            background-color: var(--mode-bg);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .digibord-content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        .digibord-content-area .diagram-area {
            width: 100%;
            max-width: 450px;
            height: 300px;
        }
        .digibord-content-area .digibord-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            width: 100%;
            max-width: 450px;
        }
        .digibord-content-area .digibord-buttons button {
            flex-grow: 1;
            max-width: 200px;
        }


        /* Numpad Container (global, shown/hidden based on mode) */
        .numpad-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 180px; /* Fixed width for numpad */
            background-color: var(--numpad-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            transition: background-color 0.3s;
            align-self: flex-start; /* Align to top in flex container */
        }

        .numpad-container button {
            width: 100%;
            padding: 15px 0;
            font-size: 1.2em;
            background-color: var(--numpad-button-bg);
            color: var(--numpad-button-text);
            border: 1px solid var(--numpad-button-hover-bg);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 0; /* Override default button margin */
        }
        .numpad-container button:hover {
            background-color: var(--numpad-button-hover-bg);
            transform: translateY(-1px);
        }
        .numpad-container button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .numpad-container button.operator {
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
        }
        .numpad-container button.operator:hover {
            background-color: var(--button-secondary-hover-bg);
        }

        @media (max-width: 768px) {
            .quiz-mode-wrapper, .digibord-mode-wrapper {
                flex-direction: column;
                align-items: center;
            }
            .numpad-container {
                width: 100%;
                max-width: 250px; /* Limit numpad width on smaller screens */
            }
            .quiz-content-area, .digibord-content-area {
                width: 100%;
                min-width: unset;
            }
            .quiz-content-area .diagram-area, .digibord-content-area .diagram-area {
                height: 250px; /* Adjust height for smaller screens */
            }
        }

        @media (max-width: 600px) {
            .container { width: 95%; padding: 15px; }
            .main-button-group button { width: auto; display: inline-block; margin: 5px; }
            h1 { font-size: 1.8rem; }
            h2 { font-size: 1.5rem; }
            .side-label { font-size: 10px; }
            .angle-label-text { font-size: 10px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script type="text/javascript" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</head>
<body>
    <div class="container">
        <h1>üìê Sinus, Cosinus, Tangens & Pythagoras</h1>
        <div class="main-button-group">
            <button id="toggleExplanationButton">Toon Uitleg</button>
            <button id="darkModeToggle">üåô Dark Mode</button>
            <button id="toggleQuizMode">Quiz Modus</button>
            <button id="toggleDigibordMode">Digibord Modus</button>
        </div>

        <div class="explanation" style="display: none;">
            <h2>Uitleg: SOL CAL TOA</h2>
            <p>In een <strong>rechthoekige driehoek</strong> kunnen we de sinus, cosinus en tangens gebruiken om de lengte van zijdes of de grootte van hoeken te berekenen. De driehoek heeft √©√©n rechte hoek (90¬∞). De zijdes hebben speciale namen ten opzichte van √©√©n van de andere (scherpe) hoeken, bijvoorbeeld hoek A:</p>
             <ul>
                 <li><strong>Langste zijde (L):</strong> Altijd de zijde tegenover de rechte hoek. Dit is de langste zijde van de driehoek. (Ook wel hypotenusa genoemd)</li>
                 <li><strong>Overstaande rechthoekszijde (O):</strong> De zijde die tegenover de hoek staat waaruit je kijkt (hoek A in dit geval).</li>
                 <li><strong>Aanliggende rechthoekszijde (A):</strong> De rechthoekszijde die aan de hoek (hoek A) vastzit, maar niet de langste zijde is.</li>
             </ul>
            <div class="triangle-container-wrapper">
                <p>Stel je een rechthoekige driehoek ABC voor, met de rechte hoek bij C. We kijken vanuit hoek A.</p>
                <svg id="explanationTriangleSvg" width="250" height="200"></svg>
                <p>(Dit is een voorbeeld driehoek.)</p>
            </div>
            <p>De basisregels (ezelsbruggetje: <strong>SOL CAL TOA</strong>):</p>
            <ul>
                <li><strong>S</strong>OL: <strong>S</strong>inus (hoek Œ±) = <strong>O</strong>verstaande / <strong>L</strong>angste ($$\sin(\alpha) = \frac{O}{L}$$)</li>
                <li><strong>C</strong>AL: <strong>C</strong>osinus (hoek Œ±) = <strong>A</strong>anliggende / <strong>L</strong>angste ($$\cos(\alpha) = \frac{A}{L}$$)</li>
                <li><strong>T</strong>OA: <strong>T</strong>angens (hoek Œ±) = <strong>O</strong>verstaande / <strong>A</strong>anliggende ($$\tan(\alpha) = \frac{O}{A}$$)</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende ZIJDE?</h3>
            <p>Als je √©√©n hoek (niet de rechte hoek) en √©√©n zijde weet, kun je een andere zijde berekenen.</p>
            <ol>
                <li><strong>Identificeer de bekende hoek ($\alpha$).</strong></li>
                <li><strong>Identificeer de bekende zijde:</strong> Is het de Overstaande (O), Aanliggende (A), of Langste (L) zijde ten opzichte van de bekende hoek?</li>
                <li><strong>Identificeer de onbekende zijde:</strong> Is dit O, A, of L?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die zowel de bekende zijde, de onbekende zijde, als de bekende hoek bevat.</li>
                <li><strong>Herschrijf de formule</strong> indien nodig om de onbekende zijde te isoleren.</li>
                <li><strong>Vul de bekende waarden in</strong> en reken de onbekende zijde uit.</li>
            </ol>
            <p><strong>Voorbeeld: Een zijde berekenen</strong></p>
            <p>Stel, hoek A = 30¬∞, en de Langste zijde (L) = 10 cm. We willen de Overstaande zijde (O) weten.</p>
            <ul>
                <li>Bekende hoek: $\alpha = 30¬∞$</li>
                <li>Bekende zijde: L = 10 cm</li>
                <li>Onbekende zijde: O = ?</li>
                <li>Formule: We hebben O en L, dus we gebruiken <strong>SOL</strong>: $$\sin(\alpha) = \frac{O}{L}$$</li>
                <li>Herschrijven: Om O te vinden, vermenigvuldigen we beide kanten met L: $$O = L \times \sin(\alpha)$$</li>
                <li>Invullen: $$O = 10 \times \sin(30¬∞) = 10 \times 0.5 = 5 \text{ cm}$$</li>
            </ul>
            <p>Andere vormen:</p>
            <ul>
                <li>Als je O weet en L zoekt met sin: $$L = \frac{O}{\sin(\alpha)}$$</li>
                <li>Als je A weet en L zoekt met cos: $$L = \frac{A}{\cos(\alpha)}$$</li>
                <li>Als je L weet en A zoekt met cos: $$A = L \times \cos(\alpha)$$</li>
                <li>Als je O weet en A zoekt met tan: $$A = \frac{O}{\tan(\alpha)}$$</li>
                <li>Als je A weet en O zoekt met tan: $$O = A \times \tan(\alpha)$$</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende HOEK?</h3>
            <p>Als je twee zijdes van de rechthoekige driehoek weet, kun je een hoek berekenen met de inverse goniometrische functies: $\sin^{-1}$ (arcsinus), $\cos^{-1}$ (arccosinus), of $\tan^{-1}$ (arctangens).</p>
            <ol>
                <li><strong>Identificeer de hoek ($\alpha$) die je wilt berekenen.</strong></li>
                <li><strong>Identificeer de twee bekende zijdes:</strong> Zijn dit O, A, en/of L ten opzichte van de te berekenen hoek?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die deze twee bekende zijdes bevat.</li>
                <li><strong>Bereken de verhouding</strong> van de zijdes (bijv. O/L).</li>
                <li><strong>Gebruik de bijbehorende inverse functie</strong> op je rekenmachine om de hoek te vinden. Zorg dat je rekenmachine op graden (degrees) staat!</li>
            </ol>
            <p><strong>Voorbeeld: Een hoek berekenen</strong></p>
            <p>Stel, de Overstaande zijde (O) = 6 cm, en de Aanliggende zijde (A) = 8 cm. We willen hoek $\alpha$ weten.</p>
            <ul>
                <li>Te berekenen hoek: $\alpha = ?$</li>
                <li>Bekende zijdes: O = 6 cm, A = 8 cm</li>
                <li>Formule: We hebben O en A, dus we gebruiken <strong>TOA</strong>: $$\tan(\alpha) = \frac{O}{A}$$</li>
                <li>Verhouding: $$\tan(\alpha) = \frac{6}{8} = 0.75$$</li>
                <li>Inverse functie: $$\alpha = \tan^{-1}(0.75)$$</li>
                <li>Uitkomst (met rekenmachine): $$\alpha \approx 36.87¬∞$$</li>
            </ul>
             <p>De inverse formules zijn dus:</p>
            <ul>
                <li>$$ \alpha = \sin^{-1}\left(\frac{O}{L}\right) $$</li>
                <li>$$ \alpha = \cos^{-1}\left(\frac{A}{L}\right) $$</li>
                <li>$$ \alpha = \tan^{-1}\left(\frac{O}{A}\right) $$</li>
            </ul>

            <h3 class="explanation-subtitle">De Stelling van Pythagoras</h3>
            <p>De stelling van Pythagoras is een fundamentele relatie in de Euclidische meetkunde tussen de drie zijden van een rechthoekige driehoek. De stelling stelt dat het kwadraat van de lengte van de langste zijde (de hypotenusa, L) gelijk is aan de som van de kwadraten van de lengtes van de twee andere zijden (de rechthoekszijden, O en A).</p>
            <p>De formule is:</p>
            <p>$$ O^2 + A^2 = L^2 $$</p>
            <p>Waarbij:</p>
            <ul>
                <li>$O$ = Overstaande rechthoekszijde</li>
                <li>$A$ = Aanliggende rechthoekszijde</li>
                <li>$L$ = Langste zijde (hypotenusa)</li>
            </ul>
            <p>Je kunt deze stelling gebruiken om een onbekende zijde te berekenen als je de andere twee zijden weet:</p>
            <ul>
                <li>Als je $O$ en $A$ weet, en $L$ zoekt: $$ L = \sqrt{O^2 + A^2} $$</li>
                <li>Als je $L$ en $O$ weet, en $A$ zoekt: $$ A = \sqrt{L^2 - O^2} $$</li>
                <li>Als je $L$ en $A$ weet, en $O$ zoekt: $$ O = \sqrt{L^2 - A^2} $$</li>
            </ul>
            <p><strong>Voorbeeld: Pythagoras</strong></p>
            <p>Stel, de Overstaande zijde (O) = 3 cm, en de Aanliggende zijde (A) = 4 cm. We willen de Langste zijde (L) weten.</p>
            <ul>
                <li>Bekende zijdes: O = 3 cm, A = 4 cm</li>
                <li>Formule: $$ O^2 + A^2 = L^2 $$</li>
                <li>Invullen: $$ 3^2 + 4^2 = L^2 $$</li>
                <li>$$ 9 + 16 = L^2 $$</li>
                <li>$$ 25 = L^2 $$</li>
                <li>$$ L = \sqrt{25} = 5 \text{ cm} $$</li>
            </ul>
        </div>

        <div class="quiz-mode-wrapper" id="quizModeWrapper">
            <div class="quiz-content-area">
                <div class="selection-menu" id="quizSelectionMenu">
                    <h3>Kies wat je wilt oefenen:</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="selectSinSides" name="questionType" value="sinSides" checked>
                        <label for="selectSinSides">Sinus (zijdes berekenen)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="selectCosSides" name="questionType" value="cosSides" checked>
                        <label for="selectCosSides">Cosinus (zijdes berekenen)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="selectTanSides" name="questionType" value="tanSides" checked>
                        <label for="selectTanSides">Tangens (zijdes berekenen)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="selectAngles" name="questionType" value="angles" checked>
                        <label for="selectAngles">Hoeken berekenen (met sin, cos, of tan)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="selectPythagoras" name="questionType" value="pythagoras" checked>
                        <label for="selectPythagoras">Stelling van Pythagoras</label>
                    </div>
                </div>

                <div class="quiz-section">
                    <h2>üéì Overhoring: Tijd om te oefenen!</h2>
                    <p id="question">Klik op "Nieuwe Vraag" om te beginnen.</p>
                    <div class="diagram-area">
                         <svg id="questionTriangleSvg" width="300" height="225"></svg>
                    </div>
                    <div class="streak-counter">Winnende streak: <span id="streakValue">0</span></div>
                    <div class="quiz-input-area">
                        <p id="answerLabel">Antwoord (1 decimaal):</p>
                        <div id="quizAnswerDisplay"></div>
                        <div class="quiz-buttons">
                            <button onclick="checkAnswer()">Controleer Antwoord</button>
                            <button onclick="newQuestion()">Nieuwe Vraag</button>
                        </div>
                    </div>
                    <div id="feedback" class="feedback-message"></div>
                    <div id="uitleg-fout" class="uitleg-extra" style="display:none;">
                        <h4>Uitleg van de oplossing:</h4>
                        <p>De gebruikte regel was: <strong id="uitleg-fout-regel"></strong></p>
                        <p>De berekening was: <strong id="uitleg-fout-berekening"></strong></p>
                        <div id="uitleg-fout-stappen-container" style="margin-top: 15px;">
                        </div>
                    </div>
                </div>
            </div>
            <div class="numpad-container" id="quizNumpad">
                <button onclick="numpadInput('1')">1</button>
                <button onclick="numpadInput('2')">2</button>
                <button onclick="numpadInput('3')">3</button>
                <button onclick="numpadInput('4')">4</button>
                <button onclick="numpadInput('5')">5</button>
                <button onclick="numpadInput('6')">6</button>
                <button onclick="numpadInput('7')">7</button>
                <button onclick="numpadInput('8')">8</button>
                <button onclick="numpadInput('9')">9</button>
                <button onclick="numpadInput('.')">.</button>
                <button onclick="numpadInput('0')">0</button>
                <button onclick="numpadInput('backspace')" class="operator">‚å´</button>
            </div>
        </div>

        <div class="digibord-mode-wrapper" id="digibordModeWrapper" style="display: none;">
            <div class="digibord-content-area">
                <div class="digibord-section">
                    <h2>Digibord</h2>
                    <p id="digibordMessage">Klik op een zijde (L, O, A) of hoek A om een waarde in te voeren.</p>
                    <div class="diagram-area">
                        <svg id="digibordTriangleSvg" width="450" height="300"></svg>
                    </div>
                    <div class="digibord-buttons">
                        <button onclick="calculateDigibord()">Bereken</button>
                        <button onclick="resetDigibord()">Reset</button>
                    </div>
                </div>
            </div>
            <div class="numpad-container" id="digibordNumpad">
                <button onclick="numpadInput('1')">1</button>
                <button onclick="numpadInput('2')">2</button>
                <button onclick="numpadInput('3')">3</button>
                <button onclick="numpadInput('4')">4</button>
                <button onclick="numpadInput('5')">5</button>
                <button onclick="numpadInput('6')">6</button>
                <button onclick="numpadInput('7')">7</button>
                <button onclick="numpadInput('8')">8</button>
                <button onclick="numpadInput('9')">9</button>
                <button onclick="numpadInput('.')">.</button>
                <button onclick="numpadInput('0')">0</button>
                <button onclick="numpadInput('backspace')" class="operator">‚å´</button>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionData = {};
        let currentStreak = 0;
        let currentMode = 'quiz'; // 'quiz' or 'digibord'

        const explanationDiv = document.querySelector('.explanation');
        const toggleExplanationButton = document.getElementById('toggleExplanationButton');
        const darkModeToggleButton = document.getElementById('darkModeToggle');

        const quizModeWrapper = document.getElementById('quizModeWrapper');
        const digibordModeWrapper = document.getElementById('digibordModeWrapper');
        const toggleQuizModeButton = document.getElementById('toggleQuizMode');
        const toggleDigibordModeButton = document.getElementById('toggleDigibordMode');

        // Quiz Mode Elements
        const questionElement = document.getElementById('question');
        const quizAnswerDisplay = document.getElementById('quizAnswerDisplay');
        const answerLabelElement = document.getElementById('answerLabel');
        const feedbackElement = document.getElementById('feedback');
        const uitlegFoutElement = document.getElementById('uitleg-fout');
        const uitlegFoutRegel = document.getElementById('uitleg-fout-regel');
        const uitlegFoutBerekening = document.getElementById('uitleg-fout-berekening');
        const uitlegStappenContainer = document.getElementById('uitleg-fout-stappen-container');
        const streakValueElement = document.getElementById('streakValue');
        const quizSelectionMenu = document.getElementById('quizSelectionMenu');

        // Digibord Mode Elements
        const digibordMessageElement = document.getElementById('digibordMessage');

        // Numpad related variables
        let currentQuizAnswerString = '';
        let activeDigibordInputKey = null; // 'L', 'O', 'A', 'angleA' for digibord
        let currentDigibordInputString = '';
        let digibordValues = {
            L: null,
            O: null,
            A: null,
            angleA: null
        };

        // Dark Mode Logic
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                darkModeToggleButton.textContent = '‚òÄÔ∏è Light Mode';
            } else {
                document.body.classList.remove('dark-mode');
                darkModeToggleButton.textContent = 'üåô Dark Mode';
            }
        }

        darkModeToggleButton.addEventListener('click', () => {
            let currentTheme = localStorage.getItem('theme');
            if (document.body.classList.contains('dark-mode')) {
                currentTheme = 'light';
            } else {
                currentTheme = 'dark';
            }
            localStorage.setItem('theme', currentTheme);
            applyTheme(currentTheme);
            // Redraw triangles to apply new SVG colors
            if (explanationDiv.style.display === 'block' && document.getElementById('explanationTriangleSvg').childNodes.length > 0) {
                drawExplanationTriangle();
            }
            if (currentMode === 'quiz') {
                redrawCurrentQuestionTriangle();
                if (uitlegFoutElement.style.display === 'block' && currentQuestionData.full_side_l) {
                    toonUitlegStappen(currentQuestionData);
                }
            } else { // digibord mode
                drawDigibordTriangle();
            }
        });
        
        // Initialize theme based on localStorage or preference
        const preferredTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        applyTheme(preferredTheme);


        toggleExplanationButton.addEventListener('click', function() {
            if (explanationDiv.style.display === 'none' || explanationDiv.style.display === '') {
                explanationDiv.style.display = 'block';
                toggleExplanationButton.textContent = 'Verberg Uitleg';
                if (document.getElementById('explanationTriangleSvg').childNodes.length === 0) { 
                    drawExplanationTriangle();
                }
            } else {
                explanationDiv.style.display = 'none';
                toggleExplanationButton.textContent = 'Toon Uitleg';
            }
        });

        toggleQuizMode.addEventListener('click', () => switchMode('quiz'));
        toggleDigibordMode.addEventListener('click', () => switchMode('digibord'));

        function switchMode(mode) {
            currentMode = mode;
            if (mode === 'quiz') {
                quizModeWrapper.style.display = 'flex';
                digibordModeWrapper.style.display = 'none';
                newQuestion(); // Start a new quiz question
            } else { // digibord
                quizModeWrapper.style.display = 'none';
                digibordModeWrapper.style.display = 'flex';
                resetDigibord(); // Reset digibord state
            }
            // Ensure MathJax re-renders for the active mode
            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function updateStreakDisplay() {
            streakValueElement.textContent = currentStreak;
        }

        function toRadians(degrees) { return degrees * (Math.PI / 180); }
        function toDegrees(radians) { return radians * (180 / Math.PI); }

        function drawExplanationTriangle() {
            const angleA_deg = 30;
            const side_a_expl = 10; 
            const side_o_expl = side_a_expl * Math.tan(toRadians(angleA_deg)); 
            const side_l_expl = side_a_expl / Math.cos(toRadians(angleA_deg)); 
            const explanationSidesConfig = {
                L: 'value', O: 'value', A: 'value', angleA: 'value'
            };
            drawTriangleGeneric(
                "explanationTriangleSvg", 
                angleA_deg, 
                side_l_expl, 
                side_o_expl, 
                side_a_expl, 
                `Hoek A (${angleA_deg.toFixed(0)}¬∞)`, 
                null, 250, 200, false, explanationSidesConfig, 'explanation'
            );
        }

        function drawTriangleGeneric(
            svgIdOrSelection, angleA_deg, 
            side_l_geom, side_o_geom, side_a_geom, 
            angleALabelText, 
            highlightItemKey = null, 
            customWidth = null, customHeight = null,
            isAngleQuestionForArc = false, 
            sidesDisplayConfig = { L: 'value', O: 'value', A: 'value', angleA: 'value' }, 
            mode // 'quiz', 'digibord', 'explanation'
        ) {
            const svg = (typeof svgIdOrSelection === 'string') ? d3.select("#" + svgIdOrSelection) : svgIdOrSelection;
            svg.selectAll("*").remove();

            const svgWidth = customWidth || parseFloat(svg.attr("width")) || 300;
            const svgHeight = customHeight || parseFloat(svg.attr("height")) || 225;

            const PADDING = customWidth ? (customWidth < 200 ? 25 : 50) : 50; 
            const availableWidth = svgWidth - 2 * PADDING;
            const availableHeight = svgHeight - 2 * PADDING;

            let scale;
            const temp_angle_rad_for_scaling = toRadians(angleA_deg !== null && angleA_deg > 0 && angleA_deg < 90 ? angleA_deg : 35);

            let ref_a = side_a_geom;
            let ref_o = side_o_geom;

            if (side_l_geom && side_l_geom > 0) {
                 if (!ref_a || ref_a <= 0) ref_a = side_l_geom * Math.cos(temp_angle_rad_for_scaling);
                 if (!ref_o || ref_o <= 0) ref_o = side_l_geom * Math.sin(temp_angle_rad_for_scaling);
            }
            if ((!ref_a || ref_a <= 0) && ref_o && ref_o > 0) {
                 ref_a = ref_o / Math.tan(temp_angle_rad_for_scaling);
            } else if ((!ref_o || ref_o <= 0) && ref_a && ref_a > 0) {
                 ref_o = ref_a * Math.tan(temp_angle_rad_for_scaling);
            }
            
            if (!ref_a || ref_a <= 0) ref_a = 10;
            if (!ref_o || ref_o <= 0) ref_o = 10 * Math.tan(temp_angle_rad_for_scaling);


            const scaleX = ref_a > 0.1 ? availableWidth / ref_a : availableWidth / 10; 
            const scaleY = ref_o > 0.1 ? availableHeight / ref_o : availableHeight / 10; 
            scale = Math.min(scaleX, scaleY);
            scale = Math.max(customWidth ? 2 : 3, Math.min(scale, customWidth ? (customWidth/10) : 25)); 

            const actual_angle_rad = toRadians(angleA_deg !== null && angleA_deg > 0 && angleA_deg < 90 ? angleA_deg : 30);

            let final_side_a_geom = side_a_geom;
            let final_side_o_geom = side_o_geom;
            let final_side_l_geom = side_l_geom;

            if (final_side_l_geom === null && final_side_o_geom !== null && final_side_a_geom !== null) {
                final_side_l_geom = Math.sqrt(final_side_o_geom**2 + final_side_a_geom**2);
            } else if (final_side_o_geom === null && final_side_l_geom !== null && final_side_a_geom !== null) {
                final_side_o_geom = final_side_l_geom * Math.sin(actual_angle_rad);
            } else if (final_side_a_geom === null && final_side_l_geom !== null && final_side_o_geom !== null) {
                final_side_a_geom = final_side_l_geom * Math.cos(actual_angle_rad);
            } else if (final_side_a_geom === null && final_side_o_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) {
                final_side_a_geom = final_side_o_geom / Math.tan(actual_angle_rad);
            } else if (final_side_o_geom === null && final_side_a_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) {
                final_side_o_geom = final_side_a_geom * Math.tan(actual_angle_rad);
            } else if (final_side_l_geom === null && final_side_o_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) {
                final_side_l_geom = final_side_o_geom / Math.sin(actual_angle_rad);
            } else if (final_side_l_geom === null && final_side_a_geom !== null && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) {
                final_side_l_geom = final_side_a_geom / Math.cos(actual_angle_rad);
            }

            if (final_side_a_geom === null || final_side_a_geom <= 0) {
                final_side_a_geom = 10;
                final_side_o_geom = final_side_a_geom * Math.tan(actual_angle_rad);
                final_side_l_geom = final_side_a_geom / Math.cos(actual_angle_rad);
            } else if (final_side_o_geom === null || final_side_o_geom <= 0) {
                final_side_o_geom = final_side_a_geom * Math.tan(actual_angle_rad);
                final_side_l_geom = final_side_a_geom / Math.cos(actual_angle_rad);
            } else if (final_side_l_geom === null || final_side_l_geom <= 0) {
                 final_side_l_geom = Math.sqrt(final_side_o_geom**2 + final_side_a_geom**2);
            }


            const final_scaled_a = final_side_a_geom * scale; 
            const final_scaled_o = final_side_o_geom * scale;

            const Cx = PADDING; 
            const Cy = svgHeight - PADDING; // Punt C (rechte hoek)
            const Ax = Cx + final_scaled_a; 
            const Ay = Cy;        // Punt A
            const Bx = Cx; 
            const By = Cy - final_scaled_o;       // Punt B
            const group = svg.append("g");

            const sideNames = {
                A: 'AC', // Aanliggende
                O: 'BC', // Overstaande
                L: 'AB'  // Langste
            };

            const rawSidesData = [
                { id: 'AC', x1: Cx, y1: Cy, x2: Ax, y2: Ay, labelKey: sideNames.A, value: final_side_a_geom, key: 'A', name: "Aanliggende", labelPos: {x: (Cx+Ax)/2, y: Ay + 15} },
                { id: 'BC', x1: Cx, y1: Cy, x2: Bx, y2: By, labelKey: sideNames.O, value: final_side_o_geom, key: 'O', name: "Overstaande", labelPos: {x: Bx - 20, y: (Cy+By)/2} },
                { id: 'AB', x1: Ax, y1: Ay, x2: Bx, y2: By, labelKey: sideNames.L, value: final_side_l_geom, key: 'L', name: "Langste", labelPos: {x: (Ax+Bx)/2 + 5, y: (Ay+By)/2 - 5} }
            ];

            const visibleSidesData = rawSidesData.filter(d => sidesDisplayConfig[d.key] !== 'hidden');

            // Draw sides
            group.selectAll(".triangle-side")
                .data(visibleSidesData)
                .enter().append("line")
                .attr("x1", d => d.x1)
                .attr("y1", d => d.y1)
                .attr("x2", d => d.x2)
                .attr("y2", d => d.y2)
                .attr("class", d => {
                    let classes = `triangle-side`;
                    if (mode === 'quiz' && highlightItemKey === d.key) {
                        classes += ' highlighted-stroke';
                    }
                    return classes;
                });

            // Draw side labels
            group.selectAll(".side-label")
                .data(visibleSidesData)
                .enter().append("text")
                .attr("x", d => d.labelPos.x)
                .attr("y", d => d.labelPos.y)
                .attr("class", d => {
                    let classes = `side-label`;
                    if (mode === 'quiz') {
                        if (highlightItemKey === d.key) classes += ' highlighted-fill';
                    } else if (mode === 'digibord') {
                        if (activeDigibordInputKey === d.key) classes += ' active-input';
                    }
                    return classes;
                })
                .text(d => {
                    if (mode === 'quiz' || mode === 'explanation') {
                        if (sidesDisplayConfig[d.key] === 'value') {
                            return `${d.labelKey} = ${d.value.toFixed(1)}`;
                        } else if (sidesDisplayConfig[d.key] === 'label') {
                            return d.labelKey;
                        }
                    } else if (mode === 'digibord') {
                        const val = digibordValues[d.key];
                        return val !== null ? `${d.labelKey} = ${val.toFixed(1)}` : `${d.labelKey} (Input)`;
                    }
                    return '';
                })
                .on("click", function(event, d) {
                    if (mode === 'digibord') {
                        setActiveDigibordInput(d.key);
                    }
                });

            // Vertices labels
            const vertices = [
                { id: 'A', x: Ax, y: Ay, label: 'A' },
                { id: 'B', x: Bx, y: By, label: 'B' },
                { id: 'C', x: Cx, y: Cy, label: 'C' }
            ];

            group.selectAll(".vertex-label")
                .data(vertices)
                .enter().append("text")
                .attr("x", d => d.x + (d.id === 'A' ? 5 : d.id === 'B' ? -15 : -15))
                .attr("y", d => d.y + (d.id === 'A' ? 15 : d.id === 'B' ? -5 : 15))
                .attr("class", "vertex-label")
                .text(d => d.label);
            
            // Angle A label (text only, no arc)
            if (sidesDisplayConfig.angleA !== 'hidden') {
                const labelOffsetRadius = 30;
                const bisectorAngleRad = toRadians(angleA_deg !== null && angleA_deg > 0 && angleA_deg < 90 ? angleA_deg : 30) / 2;

                const angleData = {
                    x: Ax,
                    y: Ay,
                    labelX: Ax + labelOffsetRadius * Math.cos(bisectorAngleRad),
                    labelY: Ay - labelOffsetRadius * Math.sin(bisectorAngleRad),
                    labelText: angleALabelText,
                    key: 'angleA'
                };

                group.append("text")
                    .attr("x", angleData.labelX)
                    .attr("y", angleData.labelY)
                    .attr("class", d => {
                        let classes = `angle-label-text`;
                        if (mode === 'quiz') {
                            if (highlightItemKey === angleData.key) classes += ' highlighted-fill';
                        } else if (mode === 'digibord') {
                            if (activeDigibordInputKey === angleData.key) classes += ' active-input';
                        }
                        return classes;
                    })
                    .text(() => {
                        if (mode === 'quiz' || mode === 'explanation') {
                            return angleALabelText;
                        } else if (mode === 'digibord') {
                            const val = digibordValues.angleA;
                            return val !== null ? `Hoek A = ${val.toFixed(1)}¬∞` : `Hoek A (Input)`;
                        }
                        return '';
                    })
                    .style("text-anchor", "middle")
                    .on("click", function() {
                        if (mode === 'digibord') {
                            setActiveDigibordInput('angleA');
                        }
                    });
            }

            // Right angle at C
            const rightAngleSize = 10;
            group.append("path")
                .attr("d", `M ${Cx + rightAngleSize},${Cy} L ${Cx + rightAngleSize},${Cy - rightAngleSize} L ${Cx},${Cy - rightAngleSize}`)
                .attr("class", "right-angle-symbol");
        }

        // Numpad Input Logic (shared for both modes)
        function numpadInput(value) {
            if (currentMode === 'quiz') {
                if (value === 'backspace') {
                    currentQuizAnswerString = currentQuizAnswerString.slice(0, -1);
                } else if (value === '.') {
                    if (!currentQuizAnswerString.includes('.')) {
                        currentQuizAnswerString += value;
                    }
                } else {
                    currentQuizAnswerString += value;
                }
                quizAnswerDisplay.textContent = currentQuizAnswerString;
            } else if (currentMode === 'digibord') {
                if (!activeDigibordInputKey) {
                    digibordMessageElement.textContent = "Selecteer eerst een zijde of hoek om in te voeren.";
                    return;
                }

                if (value === 'backspace') {
                    currentDigibordInputString = currentDigibordInputString.slice(0, -1);
                } else if (value === '.') {
                    if (!currentDigibordInputString.includes('.')) {
                        currentDigibordInputString += value;
                    }
                } else {
                    currentDigibordInputString += value;
                }
                
                digibordMessageElement.textContent = `Voer waarde in voor ${activeDigibordInputKey}: ${currentDigibordInputString}`;
                digibordValues[activeDigibordInputKey] = parseFloat(currentDigibordInputString) || null;
                drawDigibordTriangle(); // Redraw to show updated value
            }
        }

        // Quiz Mode Functions
        function redrawCurrentQuestionTriangle() {
            if (!currentQuestionData || Object.keys(currentQuestionData).length === 0 || !currentQuestionData.sidesDisplayConfig) return;

            drawTriangleGeneric(
                "questionTriangleSvg",
                currentQuestionData.isAngleQuestion || currentQuestionData.type === 'pythagoras' ? null : currentQuestionData.angleA,
                currentQuestionData.full_side_l,
                currentQuestionData.full_side_o,
                currentQuestionData.full_side_a,
                currentQuestionData.angleLabelForDisplay,
                currentQuestionData.highlightKey,
                300, 225,
                currentQuestionData.isAngleQuestion,
                currentQuestionData.sidesDisplayConfig,
                'quiz'
            );
        }

        function generateQuestion() {
            const selectedTypes = Array.from(document.querySelectorAll('.selection-menu input[name="questionType"]:checked')).map(cb => cb.value);
            if (selectedTypes.length === 0) {
                questionElement.innerHTML = "Selecteer minimaal √©√©n type vraag om te beginnen.";
                quizAnswerDisplay.textContent = "";
                feedbackElement.className = 'feedback-message';
                feedbackElement.textContent = "";
                uitlegFoutElement.style.display = 'none';
                drawTriangleGeneric("questionTriangleSvg", null, null, null, null, "", null, 300, 225, false, { L: 'label', O: 'label', A: 'label', angleA: 'label' }, 'quiz');
                return;
            }

            const questionType = selectedTypes[Math.floor(Math.random() * selectedTypes.length)];
            let angleA, sideA, sideO, sideL;
            let questionText = "";
            let correctAnswer;
            let highlightKey = null;
            let sidesDisplayConfig = { L: 'label', O: 'label', A: 'label', angleA: 'label' };
            let angleLabelText = `Hoek A = ?`;
            let isAngleQuestion = false;

            const minAngle = 20;
            const maxAngle = 70;
            const minSide = 5;
            const maxSide = 20;

            const sideNames = {
                A: 'AC', O: 'BC', L: 'AB'
            };

            if (questionType !== 'pythagoras') {
                angleA = Math.random() * (maxAngle - minAngle) + minAngle;
                angleA = parseFloat(angleA.toFixed(1)); 

                const baseSideVal = Math.random() * (maxSide - minSide) + minSide;
                sideA = parseFloat(baseSideVal.toFixed(1));
                sideO = parseFloat((sideA * Math.tan(toRadians(angleA))).toFixed(1));
                sideL = parseFloat((sideA / Math.cos(toRadians(angleA))).toFixed(1));

                if (sideO < minSide || sideL < minSide || sideO > maxSide * 2 || sideL > maxSide * 2 || isNaN(sideO) || isNaN(sideL)) {
                    return generateQuestion();
                }
            } else {
                const pythSides = [
                    { O: 3, A: 4, L: 5 }, { O: 6, A: 8, L: 10 }, { O: 5, A: 12, L: 13 },
                    { O: 8, A: 15, L: 17 }, { O: 7, A: 24, L: 25 }
                ];
                const chosenPythSet = pythSides[Math.floor(Math.random() * pythSides.length)];
                sideO = chosenPythSet.O; sideA = chosenPythSet.A; sideL = chosenPythSet.L;
                angleA = toDegrees(Math.atan(sideO / sideA)); 
            }

            let formulaText = "";
            let solveMethod = "";

            switch (questionType) {
                case 'sinSides':
                    angleLabelText = `Hoek A = ${angleA}¬∞`;
                    if (Math.random() < 0.5) { 
                        unknown = 'O'; correctAnswer = sideO;
                        questionText = `Gegeven Hoek A = ${angleA}¬∞ en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>zijde ${sideNames.O}</b>.`;
                        formulaText = `$$\\sin(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{L}}$$`;
                        solveMethod = `$$O = L \\times \\sin(\\text{Hoek A})$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'label', angleA: 'value' }; highlightKey = 'O';
                    } else { 
                        unknown = 'L'; correctAnswer = sideL;
                        questionText = `Gegeven Hoek A = ${angleA}¬∞ en zijde ${sideNames.O} = ${sideO} cm.<br>Bereken <b>zijde ${sideNames.L}</b>.`;
                        formulaText = `$$\\sin(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{L}}$$`;
                        solveMethod = `$$L = \\frac{\\text{O}}{\\sin(\\text{Hoek A})}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'label', angleA: 'value' }; highlightKey = 'L';
                    }
                    break;
                case 'cosSides':
                    angleLabelText = `Hoek A = ${angleA}¬∞`;
                    if (Math.random() < 0.5) { 
                        unknown = 'A'; correctAnswer = sideA;
                        questionText = `Gegeven Hoek A = ${angleA}¬∞ en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>zijde ${sideNames.A}</b>.`;
                        formulaText = `$$\\cos(\\text{Hoek A}) = \\frac{\\text{A}}{\\text{L}}$$`;
                        solveMethod = `$$A = L \\times \\cos(\\text{Hoek A})$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'label', angleA: 'value' }; highlightKey = 'A';
                    } else { 
                        unknown = 'L'; correctAnswer = sideL;
                        questionText = `Gegeven Hoek A = ${angleA}¬∞ en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.L}</b>.`;
                        formulaText = `$$\\cos(\\text{Hoek A}) = \\frac{\\text{A}}{\\text{L}}$$`;
                        solveMethod = `$$L = \\frac{\\text{A}}{\\cos(\\text{Hoek A})}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'label', A: 'value', angleA: 'value' }; highlightKey = 'L';
                    }
                    break;
                case 'tanSides':
                    angleLabelText = `Hoek A = ${angleA}¬∞`;
                    if (Math.random() < 0.5) { 
                        unknown = 'O'; correctAnswer = sideO;
                        questionText = `Gegeven Hoek A = ${angleA}¬∞ en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.O}</b>.`;
                        formulaText = `$$\\tan(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{A}}$$`;
                        solveMethod = `$$O = A \\times \\tan(\\text{Hoek A})$$`;
                        sidesDisplayConfig = { L: 'label', O: 'label', A: 'value', angleA: 'value' }; highlightKey = 'O';
                    } else { 
                        unknown = 'A'; correctAnswer = sideA;
                        questionText = `Gegeven Hoek A = ${angleA}¬∞ en zijde ${sideNames.O} = ${sideO} cm.<br>Bereken <b>zijde ${sideNames.A}</b>.`;
                        formulaText = `$$\\tan(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{A}}$$`;
                        solveMethod = `$$A = \\frac{\\text{O}}{\\tan(\\text{Hoek A})}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'label', angleA: 'value' }; highlightKey = 'A';
                    }
                    break;
                case 'angles':
                    isAngleQuestion = true;
                    angleLabelText = `Hoek A = ?`;
                    const angleChoice = Math.floor(Math.random() * 3);
                    if (angleChoice === 0) { 
                        unknown = 'angleA'; correctAnswer = angleA;
                        questionText = `Gegeven zijde ${sideNames.O} = ${sideO} cm en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>Hoek A</b>.`;
                        formulaText = `$$\\sin(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{L}}$$`;
                        solveMethod = `$$\\text{Hoek A} = \\sin^{-1}\\left(\\frac{\\text{O}}{\\text{L}}\\right)$$`;
                        sidesDisplayConfig = { L: 'value', O: 'value', A: 'label', angleA: 'label' }; highlightKey = 'angleA';
                    } else if (angleChoice === 1) { 
                        unknown = 'angleA'; correctAnswer = angleA;
                        questionText = `Gegeven zijde ${sideNames.A} = ${sideA} cm en zijde ${sideNames.L} = ${sideL} cm.<br>Bereken <b>Hoek A</b>.`;
                        formulaText = `$$\\cos(\\text{Hoek A}) = \\frac{\\text{A}}{\\text{L}}$$`;
                        solveMethod = `$$\\text{Hoek A} = \\cos^{-1}\\left(\\frac{\\text{A}}{\\text{L}}\\right)$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'value', angleA: 'label' }; highlightKey = 'angleA';
                    } else { 
                        unknown = 'angleA'; correctAnswer = angleA;
                        questionText = `Gegeven zijde ${sideNames.O} = ${sideO} cm en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>Hoek A</b>.`;
                        formulaText = `$$\\tan(\\text{Hoek A}) = \\frac{\\text{O}}{\\text{A}}$$`;
                        solveMethod = `$$\\text{Hoek A} = \\tan^{-1}\\left(\\frac{\\text{O}}{\\text{A}}\\right)$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'value', angleA: 'label' }; highlightKey = 'angleA';
                    }
                    break;
                case 'pythagoras':
                    isAngleQuestion = false; angleLabelText = '';
                    const unknownPythSide = ['O', 'A', 'L'][Math.floor(Math.random() * 3)];
                    if (unknownPythSide === 'L') {
                        unknown = 'L'; correctAnswer = sideL;
                        questionText = `Gegeven zijde ${sideNames.O} = ${sideO} cm en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.L}</b> met Pythagoras.`;
                        formulaText = `$$O^2 + A^2 = L^2$$`;
                        solveMethod = `$$L = \\sqrt{O^2 + A^2}$$`;
                        sidesDisplayConfig = { L: 'label', O: 'value', A: 'value', angleA: 'hidden' }; highlightKey = 'L';
                    } else if (unknownPythSide === 'O') {
                        unknown = 'O'; correctAnswer = sideO;
                        questionText = `Gegeven zijde ${sideNames.L} = ${sideL} cm en zijde ${sideNames.A} = ${sideA} cm.<br>Bereken <b>zijde ${sideNames.O}</b> met Pythagoras.`;
                        formulaText = `$$O^2 + A^2 = L^2$$`;
                        solveMethod = `$$O = \\sqrt{L^2 - A^2}$$`;
                        sidesDisplayConfig = { L: 'value', O: 'label', A: 'value', angleA: 'hidden' }; highlightKey = 'O';
                    } else { 
                        unknown = 'A'; correctAnswer = sideA;
                        questionText = `Gegeven zijde ${sideNames.L} = ${sideL} cm en zijde ${sideNames.O} = ${sideO} cm.<br>Bereken <b>zijde ${sideNames.A}</b> met Pythagoras.`;
                        formulaText = `$$O^2 + A^2 = L^2$$`;
                        solveMethod = `$$A = \\sqrt{L^2 - O^2}$$`;
                        sidesDisplayConfig = { L: 'value', O: 'value', A: 'label', angleA: 'hidden' }; highlightKey = 'A';
                    }
                    break;
                default:
                    questionText = "Selecteer een vraagtype en klik op 'Nieuwe Vraag'.";
                    correctAnswer = 0;
            }
            
            currentQuestionData = {
                type: questionType, angleA: angleA, sideA: sideA, sideO: sideO, sideL: sideL,
                full_side_a: sideA, full_side_o: sideO, full_side_l: sideL,
                correctAnswer: parseFloat(correctAnswer.toFixed(1)),
                questionText: questionText, unknown: unknown, formulaText: formulaText,
                solveMethod: solveMethod, calculationSteps: [], highlightKey: highlightKey,
                sidesDisplayConfig: sidesDisplayConfig, angleLabelForDisplay: angleLabelText,
                isAngleQuestion: isAngleQuestion, sideNames: sideNames
            };

            if (questionType === 'sinSides' || questionType === 'cosSides' || questionType === 'tanSides') {
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: (unknown === 'O' || unknown === 'L') ? 'L' : ((unknown === 'A' || unknown === 'L') ? 'A' : 'O'),
                    isAngleQuestion: false, sidesDisplayConfig: { L: (unknown === 'L' || unknown === 'O') ? 'value' : 'label', O: (unknown === 'O' || unknown === 'L') ? 'label' : 'value', A: (unknown === 'A' || unknown === 'L') ? 'value' : 'label', angleA: 'value' },
                    stepText: `We kennen Hoek A = ${angleA}¬∞ en zijde ${sideNames[Object.keys(currentQuestionData.sidesDisplayConfig).find(k => currentQuestionData.sidesDisplayConfig[k] === 'value')] || ''} = ${currentQuestionData[`full_side_${Object.keys(currentQuestionData.sidesDisplayConfig).find(k => currentQuestionData.sidesDisplayConfig[k] === 'value')}`]} cm. We zoeken zijde ${sideNames[unknown]}.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: unknown, isAngleQuestion: false,
                    sidesDisplayConfig: sidesDisplayConfig,
                    stepText: `De formule is ${formulaText}. Om ${sideNames[unknown]} te vinden, herschikken we naar ${solveMethod}.`
                });
            } else if (questionType === 'angles') {
                const knownSide1Key = Object.keys(sidesDisplayConfig).find(k => sidesDisplayConfig[k] === 'value');
                const knownSide2Key = Object.keys(sidesDisplayConfig).filter(k => sidesDisplayConfig[k] === 'value')[1];

                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: knownSide1Key, isAngleQuestion: true,
                    sidesDisplayConfig: { L: sidesDisplayConfig['L'], O: sidesDisplayConfig['O'], A: sidesDisplayConfig['A'], angleA: 'label' },
                    stepText: `We kennen zijde ${sideNames[knownSide1Key]} = ${currentQuestionData[`full_side_${knownSide1Key}`]} cm en zijde ${sideNames[knownSide2Key]} = ${currentQuestionData[`full_side_${knownSide2Key}`]} cm. We zoeken Hoek A.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: 'angleA', isAngleQuestion: true,
                    sidesDisplayConfig: sidesDisplayConfig,
                    stepText: `De formule is ${formulaText}. Om Hoek A te vinden, gebruiken we de inverse functie: ${solveMethod}.`
                });
            } else if (questionType === 'pythagoras') {
                let knownSide1 = ''; let knownSide2 = '';
                if (unknown === 'L') { knownSide1 = 'O'; knownSide2 = 'A'; }
                else if (unknown === 'O') { knownSide1 = 'L'; knownSide2 = 'A'; }
                else { knownSide1 = 'L'; knownSide2 = 'O'; }

                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: knownSide1, isAngleQuestion: false,
                    sidesDisplayConfig: { L: knownSide1 === 'L' ? 'value' : 'label', O: knownSide1 === 'O' ? 'value' : 'label', A: knownSide1 === 'A' ? 'value' : 'label', angleA: 'hidden' },
                    stepText: `We kennen zijde ${sideNames[knownSide1]} = ${currentQuestionData[`full_side_${knownSide1}`]} cm. We zoeken zijde ${sideNames[unknown]}.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: knownSide2, isAngleQuestion: false,
                    sidesDisplayConfig: { L: (knownSide1 === 'L' || knownSide2 === 'L') ? 'value' : 'label', O: (knownSide1 === 'O' || knownSide2 === 'O') ? 'value' : 'label', A: (knownSide1 === 'A' || knownSide2 === 'A') ? 'value' : 'label', angleA: 'hidden' },
                    stepText: `We kennen ook zijde ${sideNames[knownSide2]} = ${currentQuestionData[`full_side_${knownSide2}`]} cm. De stelling van Pythagoras is $O^2 + A^2 = L^2$.`
                });
                currentQuestionData.calculationSteps.push({
                    diagramType: 'questionTriangleSvg', angleA: angleA, full_side_l: sideL, full_side_o: sideO, full_side_a: sideA,
                    angleLabelForDisplay: angleLabelText, highlightKey: unknown, isAngleQuestion: false,
                    sidesDisplayConfig: sidesDisplayConfig,
                    stepText: `Om ${sideNames[unknown]} te vinden, herschikken we naar ${solveMethod}.`
                });
            }

            questionElement.innerHTML = currentQuestionData.questionText;
            answerLabelElement.textContent = `Antwoord (${currentQuestionData.unknown === 'angleA' ? 'graden' : 'cm'}, 1 decimaal):`;
            currentQuizAnswerString = ''; // Clear input string for new question
            quizAnswerDisplay.textContent = '';
            feedbackElement.className = 'feedback-message';
            feedbackElement.textContent = "";
            uitlegFoutElement.style.display = 'none';

            drawTriangleGeneric(
                "questionTriangleSvg",
                currentQuestionData.isAngleQuestion || currentQuestionData.type === 'pythagoras' ? null : angleA,
                sideL, sideO, sideA,
                angleLabelText,
                highlightKey, 300, 225,
                currentQuestionData.isAngleQuestion,
                currentQuestionData.sidesDisplayConfig,
                'quiz'
            );

            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function checkAnswer() {
            const userAnswer = parseFloat(currentQuizAnswerString);
            if (isNaN(userAnswer)) {
                feedbackElement.className = 'feedback-message incorrect';
                feedbackElement.textContent = "Voer een geldig getal in.";
                currentStreak = 0;
                updateStreakDisplay();
                return;
            }

            const correctAnswer = currentQuestionData.correctAnswer;
            const tolerance = 0.1;

            if (Math.abs(userAnswer - correctAnswer) <= tolerance) {
                feedbackElement.className = 'feedback-message correct';
                feedbackElement.textContent = `Correct! Het antwoord is ${correctAnswer.toFixed(1)}.`;
                uitlegFoutElement.style.display = 'none';
                currentStreak++;
                updateStreakDisplay();
                // Optionally, automatically generate a new question after a short delay
                setTimeout(newQuestion, 1500); 
            } else {
                feedbackElement.className = 'feedback-message incorrect';
                feedbackElement.textContent = `Niet helemaal correct. Jouw antwoord: ${userAnswer.toFixed(1)}. Het juiste antwoord is ${correctAnswer.toFixed(1)}.`;
                currentStreak = 0;
                updateStreakDisplay();
                uitlegFoutElement.style.display = 'block';
                toonUitlegStappen(currentQuestionData);
            }

            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function toonUitlegStappen(data) {
            uitlegFoutRegel.innerHTML = data.formulaText;
            uitlegFoutBerekening.innerHTML = data.solveMethod;
            uitlegStappenContainer.innerHTML = '';

            data.calculationSteps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'stap-uitleg';
                stepDiv.innerHTML = `<h5>Stap ${index + 1}</h5><p>${step.stepText}</p><div class="diagram-area"><svg id="uitlegStepSvg${index}" width="250" height="200"></svg></div>`;
                uitlegStappenContainer.appendChild(stepDiv);

                drawTriangleGeneric(
                    `uitlegStepSvg${index}`,
                    step.isAngleQuestion || data.type === 'pythagoras' ? null : step.angleA, 
                    step.full_side_l, step.full_side_o, step.full_side_a,
                    step.angleLabelForDisplay,
                    step.highlightKey, 250, 200, 
                    step.isAngleQuestion,
                    step.sidesDisplayConfig,
                    'quiz'
                );
            });

            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function newQuestion() {
            generateQuestion();
            currentQuizAnswerString = '';
            quizAnswerDisplay.textContent = '';
            feedbackElement.className = 'feedback-message';
            feedbackElement.textContent = "";
            uitlegFoutElement.style.display = 'none';
        }

        // Event listeners for checkboxes to ensure at least one is selected
        const checkboxes = document.querySelectorAll('.selection-menu input[name="questionType"]');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const checkedCount = document.querySelectorAll('.selection-menu input[name="questionType"]:checked').length;
                if (checkedCount === 0) {
                    checkbox.checked = true;
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background-color: var(--container-bg);
                        color: var(--text-color);
                        padding: 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                        z-index: 1000;
                        text-align: center;
                    `;
                    messageBox.innerHTML = `
                        <p>Minimaal √©√©n vraagtype moet geselecteerd zijn.</p>
                        <button onclick="this.parentNode.remove()" style="margin-top: 10px; padding: 8px 15px; background-color: var(--button-primary-bg); color: var(--button-primary-text); border: none; border-radius: 4px; cursor: pointer;">OK</button>
                    `;
                    document.body.appendChild(messageBox);
                }
            });
        });

        // Digibord Mode Functions
        function setActiveDigibordInput(key) {
            activeDigibordInputKey = key;
            currentDigibordInputString = digibordValues[key] !== null ? digibordValues[key].toString() : '';
            digibordMessageElement.textContent = `Voer waarde in voor ${key}: ${currentDigibordInputString}`;
            drawDigibordTriangle(); // Redraw to highlight active input
        }

        function calculateDigibord() {
            const L = digibordValues.L;
            const O = digibordValues.O;
            const A = digibordValues.A;
            let angleA_deg = digibordValues.angleA;

            const knownCount = [L, O, A, angleA_deg].filter(val => val !== null).length;
            const unknownCount = 4 - knownCount;

            if (knownCount < 2) {
                digibordMessageElement.textContent = "Voer minimaal twee waarden in (zijden of hoek) om te berekenen.";
                return;
            }
            if (knownCount > 2 && unknownCount > 0) {
                digibordMessageElement.textContent = "Te veel waarden ingevoerd. Reset en probeer het opnieuw met exact twee bekende waarden.";
                return;
            }

            let calculatedL = L, calculatedO = O, calculatedA = A, calculatedAngleA_deg = angleA_deg;
            let resultMessage = "Resultaten: ";

            try {
                if (knownCount === 2) {
                    if (L !== null && O !== null) { // Find A or angleA
                        calculatedA = Math.sqrt(L*L - O*O);
                        calculatedAngleA_deg = toDegrees(Math.asin(O / L));
                        resultMessage += `A = ${calculatedA.toFixed(1)}, Hoek A = ${calculatedAngleA_deg.toFixed(1)}¬∞`;
                    } else if (L !== null && A !== null) { // Find O or angleA
                        calculatedO = Math.sqrt(L*L - A*A);
                        calculatedAngleA_deg = toDegrees(Math.acos(A / L));
                        resultMessage += `O = ${calculatedO.toFixed(1)}, Hoek A = ${calculatedAngleA_deg.toFixed(1)}¬∞`;
                    } else if (O !== null && A !== null) { // Find L or angleA
                        calculatedL = Math.sqrt(O*O + A*A);
                        calculatedAngleA_deg = toDegrees(Math.atan(O / A));
                        resultMessage += `L = ${calculatedL.toFixed(1)}, Hoek A = ${calculatedAngleA_deg.toFixed(1)}¬∞`;
                    } else if (L !== null && angleA_deg !== null) { // Find O and A
                        calculatedO = L * Math.sin(toRadians(angleA_deg));
                        calculatedA = L * Math.cos(toRadians(angleA_deg));
                        resultMessage += `O = ${calculatedO.toFixed(1)}, A = ${calculatedA.toFixed(1)}`;
                    } else if (O !== null && angleA_deg !== null) { // Find L and A
                        calculatedL = O / Math.sin(toRadians(angleA_deg));
                        calculatedA = O / Math.tan(toRadians(angleA_deg));
                        resultMessage += `L = ${calculatedL.toFixed(1)}, A = ${calculatedA.toFixed(1)}`;
                    } else if (A !== null && angleA_deg !== null) { // Find L and O
                        calculatedL = A / Math.cos(toRadians(angleA_deg));
                        calculatedO = A * Math.tan(toRadians(angleA_deg));
                        resultMessage += `L = ${calculatedL.toFixed(1)}, O = ${calculatedO.toFixed(1)}`;
                    } else {
                        digibordMessageElement.textContent = "Ongeldige combinatie van bekende waarden. Probeer het opnieuw.";
                        return;
                    }
                } else if (knownCount === 3) {
                    if (L !== null && O !== null && A !== null) {
                        const pythCheck = Math.sqrt(O*O + A*A);
                        if (Math.abs(pythCheck - L) > 0.1) {
                            digibordMessageElement.textContent = "De ingevoerde zijden voldoen niet aan Pythagoras. Controleer je waarden.";
                            return;
                        }
                        calculatedAngleA_deg = toDegrees(Math.atan(O / A));
                        resultMessage += `Hoek A = ${calculatedAngleA_deg.toFixed(1)}¬∞ (consistent)`;
                    } else if (L !== null && O !== null && angleA_deg !== null) {
                        calculatedA = O / Math.tan(toRadians(angleA_deg));
                        resultMessage += `A = ${calculatedA.toFixed(1)}`;
                    } else if (L !== null && A !== null && angleA_deg !== null) {
                        calculatedO = A * Math.tan(toRadians(angleA_deg));
                        resultMessage += `O = ${calculatedO.toFixed(1)}`;
                    } else if (O !== null && A !== null && angleA_deg !== null) {
                        calculatedL = Math.sqrt(O*O + A*A);
                        resultMessage += `L = ${calculatedL.toFixed(1)}`;
                    }
                }

                digibordValues.L = calculatedL;
                digibordValues.O = calculatedO;
                digibordValues.A = calculatedA;
                digibordValues.angleA = calculatedAngleA_deg;
                digibordMessageElement.textContent = resultMessage;
                activeDigibordInputKey = null;
                currentDigibordInputString = '';
                drawDigibordTriangle();
            } catch (e) {
                digibordMessageElement.textContent = "Fout bij berekening. Controleer de ingevoerde waarden (bijv. wortel uit negatief getal of hoek buiten bereik).";
                console.error(e);
            }
            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function resetDigibord() {
            digibordValues = { L: null, O: null, A: null, angleA: null };
            activeDigibordInputKey = null;
            currentDigibordInputString = '';
            digibordMessageElement.textContent = "Klik op een zijde (L, O, A) of hoek A om een waarde in te voeren.";
            drawDigibordTriangle();
            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        function drawDigibordTriangle() {
            const config = {
                L: digibordValues.L !== null ? 'value' : 'input',
                O: digibordValues.O !== null ? 'value' : 'input',
                A: digibordValues.A !== null ? 'value' : 'input',
                angleA: digibordValues.angleA !== null ? 'value' : 'input'
            };
            drawTriangleGeneric(
                "digibordTriangleSvg",
                digibordValues.angleA,
                digibordValues.L, digibordValues.O, digibordValues.A,
                `Hoek A (${digibordValues.angleA !== null ? digibordValues.angleA.toFixed(1) : '?'})¬∞`,
                null, 450, 300,
                digibordValues.angleA === null,
                config,
                'digibord'
            );
            if (window.MathJax) {
                MathJax.typesetPromise().then(() => {});
            }
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('quiz'); // Start in Quiz Mode by default
        });
    </script>
</body>
</html>
