<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leren over Sinus, Cosinus & Tangens (D3.js)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f0f9ff;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top for long content */
            min-height: 100vh;
            padding-top: 20px;
            padding-bottom: 20px;
        }
        .container {
            max-width: 800px;
            width: 90%;
            margin: 20px auto;
            background: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #005A9C;
            text-align: center;
            margin-bottom: 20px;
        }
        h3.explanation-subtitle { /* New style for subtitles in explanation */
            color: #007bff;
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px solid #bde0fe;
            padding-bottom: 5px;
        }
        .explanation, .quiz, .feedback-section, .selection-menu { /* Added .selection-menu */
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #bde0fe;
            border-radius: 8px;
            background-color: #e7f5ff;
        }
        .triangle-container-wrapper, #triangle-diagram {
            text-align: center;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            border-radius: 6px;
            padding: 10px;
            border: 1px solid #dee2e6;
        }
        svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        input[type="number"] {
            padding: 10px;
            margin-right: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 1rem;
            width: calc(50% - 15px);
        }
        button {
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }
        button:hover { background-color: #0056b3; }
        button:active { background-color: #004085; }
        #toggleExplanationButton {
            background-color: #6c757d; /* Secondary color */
            margin-bottom: 15px;
        }
        #toggleExplanationButton:hover {
            background-color: #5a6268;
        }

        .streak-counter {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #005A9C;
            margin-bottom: 15px;
        }
        .streak-counter span {
            color: #007bff;
            font-size: 1.3em;
        }

        .correct { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb; padding: 10px; border-radius: 6px; }
        .incorrect { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px; border-radius: 6px; }
        #feedback { margin-top: 15px; font-weight: bold; min-height: 50px; }
        .uitleg-extra {
            display: block;
            margin-top:15px;
            padding:15px;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 6px;
        }
        ul { list-style-position: inside; padding-left: 20px; }
        li { margin-bottom: 8px; }
        .explanation ul li { margin-bottom: 10px; } /* More spacing for explanation list items */
        .explanation p { margin-bottom: 12px; }

        .triangle-side { stroke-linecap: round; }
        .vertex-label { font-family: 'Inter', sans-serif; fill: #005A9C; font-weight: bold; font-size: 14px; }
        .side-label { font-family: 'Inter', sans-serif; fill: #007bff; font-size: 12px; text-anchor: middle; }
        .angle-label-text { font-family: 'Inter', sans-serif; fill: red; font-size: 12px; font-weight: bold; }
        .right-angle-symbol { stroke: #555; fill: none; }

        #uitleg-fout-stappen-container .stap-uitleg {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px dashed #007bff;
            border-radius: 6px;
            background-color: #e7f5ff;
        }
        #uitleg-fout-stappen-container h5 {
            color: #005A9C;
            margin-top: 0;
        }
        #uitleg-fout-stappen-container svg {
            border: 1px solid #ccc;
            background-color: #fff;
        }

        /* Styles for selection menu */
        .selection-menu h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #005A9C;
            font-size: 1.2em;
            text-align: left;
        }
        .selection-menu .checkbox-group { 
            margin-bottom: 10px;
            display: flex; 
            align-items: center;
        }
        .selection-menu label {
            margin-left: 8px;
            font-size: 1em; 
            color: #333;
            cursor: pointer;
        }
        .selection-menu input[type="checkbox"] {
            transform: scale(1.2); 
            cursor: pointer;
            margin-right: 5px; 
        }


        @media (max-width: 600px) {
            .container { width: 95%; padding: 15px; }
            input[type="number"] { width: calc(100% - 20px); margin-bottom: 10px; }
            button { width: 100%; margin-top: 5px; }
            h1 { font-size: 1.8rem; }
            h2 { font-size: 1.5rem; }
            .selection-menu h3 { font-size: 1.1em; }
            .selection-menu label { font-size: 0.9em; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <h1>üìê Sinus, Cosinus en Tangens Leren </h1>
        <div style="text-align: center;">
            <button id="toggleExplanationButton">Toon Uitleg</button>
        </div>
        <div class="streak-counter">Winnende streak: <span id="streakValue">0</span></div>

        <div class="explanation" style="display: none;"> {/* Start verborgen */}
            <h2>Uitleg: SOL CAL TOA</h2>
            <p>In een <strong>rechthoekige driehoek</strong> kunnen we de sinus, cosinus en tangens gebruiken om de lengte van zijdes of de grootte van hoeken te berekenen. De driehoek heeft √©√©n rechte hoek (90¬∞). De zijdes hebben speciale namen ten opzichte van √©√©n van de andere (scherpe) hoeken, bijvoorbeeld hoek A:</p>
             <ul>
                <li><strong>Langste zijde (L):</strong> Altijd de zijde tegenover de rechte hoek. Dit is de langste zijde van de driehoek. (Ook wel hypotenusa genoemd)</li>
                <li><strong>Overstaande rechthoekszijde (O):</strong> De zijde die tegenover de hoek staat waaruit je kijkt (hoek A in dit geval).</li>
                <li><strong>Aanliggende rechthoekszijde (A):</strong> De rechthoekszijde die aan de hoek (hoek A) vastzit, maar niet de langste zijde is.</li>
            </ul>
            <div class="triangle-container-wrapper">
                <p>Stel je een rechthoekige driehoek ABC voor, met de rechte hoek bij C. We kijken vanuit hoek A.</p>
                <svg id="explanationTriangleSvg" width="250" height="200"></svg>
                <p>(Dit is een voorbeeld driehoek.)</p>
            </div>
            <p>De basisregels (ezelsbruggetje: <strong>SOL CAL TOA</strong>):</p>
            <ul>
                <li><strong>S</strong>OL: <strong>S</strong>inus (hoek Œ±) = <strong>O</strong>verstaande / <strong>L</strong>angste  ($$\sin(\alpha) = \frac{O}{L}$$)</li>
                <li><strong>C</strong>AL: <strong>C</strong>osinus (hoek Œ±) = <strong>A</strong>anliggende / <strong>L</strong>angste ($$\cos(\alpha) = \frac{A}{L}$$)</li>
                <li><strong>T</strong>OA: <strong>T</strong>angens (hoek Œ±) = <strong>O</strong>verstaande / <strong>A</strong>anliggende ($$\tan(\alpha) = \frac{O}{A}$$)</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende ZIJDE?</h3>
            <p>Als je √©√©n hoek (niet de rechte hoek) en √©√©n zijde weet, kun je een andere zijde berekenen.</p>
            <ol>
                <li><strong>Identificeer de bekende hoek ($\alpha$).</strong></li>
                <li><strong>Identificeer de bekende zijde:</strong> Is het de Overstaande (O), Aanliggende (A), of Langste (L) zijde ten opzichte van de bekende hoek?</li>
                <li><strong>Identificeer de onbekende zijde:</strong> Is dit O, A, of L?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die zowel de bekende zijde, de onbekende zijde, als de bekende hoek bevat.</li>
                <li><strong>Herschrijf de formule</strong> indien nodig om de onbekende zijde te isoleren.</li>
                <li><strong>Vul de bekende waarden in</strong> en reken de onbekende zijde uit.</li>
            </ol>
            <p><strong>Voorbeeld: Een zijde berekenen</strong></p>
            <p>Stel, hoek A = 30¬∞, en de Langste zijde (L) = 10 cm. We willen de Overstaande zijde (O) weten.</p>
            <ul>
                <li>Bekende hoek: $\alpha = 30¬∞$</li>
                <li>Bekende zijde: L = 10 cm</li>
                <li>Onbekende zijde: O = ?</li>
                <li>Formule: We hebben O en L, dus we gebruiken <strong>SOL</strong>:  $$\sin(\alpha) = \frac{O}{L}$$</li>
                <li>Herschrijven: Om O te vinden, vermenigvuldigen we beide kanten met L: $$O = L \times \sin(\alpha)$$</li>
                <li>Invullen: $$O = 10 \times \sin(30¬∞) = 10 \times 0.5 = 5 \text{ cm}$$</li>
            </ul>
            <p>Andere vormen:</p>
            <ul>
                <li>Als je O weet en L zoekt met sin: $$L = \frac{O}{\sin(\alpha)}$$</li>
                <li>Als je A weet en L zoekt met cos: $$L = \frac{A}{\cos(\alpha)}$$</li>
                <li>Als je L weet en A zoekt met cos: $$A = L \times \cos(\alpha)$$</li>
                <li>Als je O weet en A zoekt met tan: $$A = \frac{O}{\tan(\alpha)}$$</li>
                <li>Als je A weet en O zoekt met tan: $$O = A \times \tan(\alpha)$$</li>
            </ul>

            <h3 class="explanation-subtitle">Hoe bereken je een onbekende HOEK?</h3>
            <p>Als je twee zijdes van de rechthoekige driehoek weet, kun je een hoek berekenen met de inverse goniometrische functies: $\sin^{-1}$ (arcsinus), $\cos^{-1}$ (arccosinus), of $\tan^{-1}$ (arctangens).</p>
            <ol>
                <li><strong>Identificeer de hoek ($\alpha$) die je wilt berekenen.</strong></li>
                <li><strong>Identificeer de twee bekende zijdes:</strong> Zijn dit O, A, en/of L ten opzichte van de te berekenen hoek?</li>
                <li><strong>Kies de juiste formule (SOL, CAL, of TOA)</strong> die deze twee bekende zijdes bevat.</li>
                <li><strong>Bereken de verhouding</strong> van de zijdes (bijv. O/L).</li>
                <li><strong>Gebruik de bijbehorende inverse functie</strong> op je rekenmachine om de hoek te vinden. Zorg dat je rekenmachine op graden (degrees) staat!</li>
            </ol>
            <p><strong>Voorbeeld: Een hoek berekenen</strong></p>
            <p>Stel, de Overstaande zijde (O) = 6 cm, en de Aanliggende zijde (A) = 8 cm. We willen hoek $\alpha$ weten.</p>
            <ul>
                <li>Te berekenen hoek: $\alpha = ?$</li>
                <li>Bekende zijdes: O = 6 cm, A = 8 cm</li>
                <li>Formule: We hebben O en A, dus we gebruiken <strong>TOA</strong>: $$\tan(\alpha) = \frac{O}{A}$$</li>
                <li>Verhouding: $$\tan(\alpha) = \frac{6}{8} = 0.75$$</li>
                <li>Inverse functie: $$\alpha = \tan^{-1}(0.75)$$</li>
                <li>Uitkomst (met rekenmachine): $$\alpha \approx 36.87¬∞$$</li>
            </ul>
             <p>De inverse formules zijn dus:</p>
            <ul>
                <li>$$ \alpha = \sin^{-1}\left(\frac{O}{L}\right) $$</li>
                <li>$$ \alpha = \cos^{-1}\left(\frac{A}{L}\right) $$</li>
                <li>$$ \alpha = \tan^{-1}\left(\frac{O}{A}\right) $$</li>
            </ul>
        </div>

        <div class="selection-menu">
            <h3>Kies wat je wilt oefenen:</h3>
            <div class="checkbox-group">
                <input type="checkbox" id="selectSinSides" name="questionType" value="sinSides" checked>
                <label for="selectSinSides">Sinus (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectCosSides" name="questionType" value="cosSides" checked>
                <label for="selectCosSides">Cosinus (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectTanSides" name="questionType" value="tanSides" checked>
                <label for="selectTanSides">Tangens (zijdes berekenen)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="selectAngles" name="questionType" value="angles" checked>
                <label for="selectAngles">Hoeken berekenen (met sin, cos, of tan)</label>
            </div>
        </div>

        <div class="quiz">
            <h2>üéì Overhoring: Tijd om te oefenen!</h2>
            <p id="question">Klik op "Nieuwe Vraag" om te beginnen.</p>
            <div id="triangle-diagram">
                 <svg id="questionTriangleSvg" width="300" height="225"></svg>
            </div>
            <div>
                <label for="answer" id="answerLabel">Antwoord (getal, 1 decimaal): </label>
                <input type="number" id="answer" step="0.1" placeholder="bv. 7.3">
            </div>
            <button onclick="checkAnswer()">Controleer Antwoord</button>
            <button onclick="newQuestion()">Nieuwe Vraag</button>
            <div id="feedback" class="feedback-section"></div>
            <div id="uitleg-fout" class="uitleg-extra" style="display:none;">
                <h4>Uitleg van de oplossing:</h4>
                <p>De gebruikte regel was: <strong id="uitleg-fout-regel"></strong></p>
                <p>De berekening was: <strong id="uitleg-fout-berekening"></strong></p>
                <div id="uitleg-fout-stappen-container" style="margin-top: 15px;">
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestionData = {};
        let currentStreak = 0;
        let lastQuestionTypeOnError = null; 

        const questionElement = document.getElementById('question');
        const answerElement = document.getElementById('answer');
        const answerLabelElement = document.getElementById('answerLabel');
        const feedbackElement = document.getElementById('feedback');
        const uitlegFoutElement = document.getElementById('uitleg-fout');
        const uitlegFoutRegel = document.getElementById('uitleg-fout-regel');
        const uitlegFoutBerekening = document.getElementById('uitleg-fout-berekening');
        const uitlegStappenContainer = document.getElementById('uitleg-fout-stappen-container');
        const explanationDiv = document.querySelector('.explanation');
        const toggleExplanationButton = document.getElementById('toggleExplanationButton');
        const streakValueElement = document.getElementById('streakValue');

        // Checkbox elements
        const selectSinSidesCb = document.getElementById('selectSinSides');
        const selectCosSidesCb = document.getElementById('selectCosSides');
        const selectTanSidesCb = document.getElementById('selectTanSides');
        const selectAnglesCb = document.getElementById('selectAngles');


        toggleExplanationButton.addEventListener('click', function() {
            if (explanationDiv.style.display === 'none' || explanationDiv.style.display === '') {
                explanationDiv.style.display = 'block';
                toggleExplanationButton.textContent = 'Verberg Uitleg';
                if (document.getElementById('explanationTriangleSvg').childNodes.length === 0) { 
                     drawExplanationTriangle();
                }
            } else {
                explanationDiv.style.display = 'none';
                toggleExplanationButton.textContent = 'Toon Uitleg';
            }
        });

        function updateStreakDisplay() {
            streakValueElement.textContent = currentStreak;
        }

        function toRadians(degrees) { return degrees * (Math.PI / 180); }
        function toDegrees(radians) { return radians * (180 / Math.PI); }

        function drawExplanationTriangle() {
            const angleA_deg = 30;
            const side_a_expl = 10; // Aanliggende
            const side_o_expl = side_a_expl * Math.tan(toRadians(angleA_deg)); // Overstaande
            const side_l_expl = side_a_expl / Math.cos(toRadians(angleA_deg)); // Langste
            // Parameters: svgId, angleA, L, O, A, labelAngleA, labelL, labelO, labelA, highlightKeys, customWidth, customHeight, showSidePrefixes, isAngleQuestion
            drawTriangleGeneric("explanationTriangleSvg", angleA_deg, side_l_expl, side_o_expl, side_a_expl, "Hoek A", "Langste (L)", "Overst. (O)", "Aanlig. (A)", null, 250, 200, true, false);
        }

        function drawTriangleGeneric(svgIdOrSelection, angleA_deg, side_l, side_o, side_a, labelAngleA, labelL, labelO, labelA, highlightKeys = null, customWidth = null, customHeight = null, showSidePrefixes = true, isAngleQuestion = false) { 
            const svg = (typeof svgIdOrSelection === 'string') ? d3.select("#" + svgIdOrSelection) : svgIdOrSelection;
            svg.selectAll("*").remove();

            const svgWidth = customWidth || parseFloat(svg.attr("width"));
            const svgHeight = customHeight || parseFloat(svg.attr("height"));

            const PADDING = customWidth ? 20 : 30; 
            const availableWidth = svgWidth - 2 * PADDING;
            const availableHeight = svgHeight - 2 * PADDING;

            let scale;
            const temp_angle_rad_for_scaling = toRadians(angleA_deg || 30);


            let ref_a = side_a, ref_o = side_o;

            if (side_l && side_l > 0) {
                if (side_a === null || side_a === undefined || side_a <= 0) ref_a = side_l * Math.cos(temp_angle_rad_for_scaling);
                if (side_o === null || side_o === undefined || side_o <= 0) ref_o = side_l * Math.sin(temp_angle_rad_for_scaling);
            }
            
            if (!ref_a || ref_a <= 0) {
                ref_a = (ref_o && ref_o > 0 && temp_angle_rad_for_scaling > 0.01 && temp_angle_rad_for_scaling < Math.PI/2 - 0.01) ? ref_o / Math.tan(temp_angle_rad_for_scaling) : 10;
            }
            if (!ref_o || ref_o <= 0) {
                ref_o = (ref_a && ref_a > 0 && temp_angle_rad_for_scaling > 0.01 && temp_angle_rad_for_scaling < Math.PI/2 - 0.01) ? ref_a * Math.tan(temp_angle_rad_for_scaling) : 10;
            }

            const scaleX = ref_a > 0.1 ? availableWidth / ref_a : availableWidth / 10; 
            const scaleY = ref_o > 0.1 ? availableHeight / ref_o : availableHeight / 10; 
            scale = Math.min(scaleX, scaleY);
            scale = Math.max(customWidth ? 2 : 3, Math.min(scale, customWidth ? 15 : 25)); 

            const actual_angle_rad = (angleA_deg !== null && angleA_deg !== undefined) ? toRadians(angleA_deg) : temp_angle_rad_for_scaling;

            const scaled_a_val = side_a !== null && side_a !== undefined ? side_a * scale : 
                                 ( (side_l !== null && side_l !== undefined && side_o !== null && side_o !== undefined) ? Math.sqrt(Math.max(0.1,(side_l*scale)**2 - (side_o*scale)**2)) : 
                                 ( (side_l !== null && side_l !== undefined) ? (side_l*scale) * Math.cos(actual_angle_rad) : 
                                 ( (side_o !== null && side_o !== undefined && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) ? (side_o*scale) / Math.tan(actual_angle_rad) : 10*scale ) ) );
            
            const scaled_o_val = side_o !== null && side_o !== undefined ? side_o * scale : 
                                 ( (side_l !== null && side_l !== undefined && side_a !== null && side_a !== undefined) ? Math.sqrt(Math.max(0.1,(side_l*scale)**2 - (side_a*scale)**2)) : 
                                 ( (side_l !== null && side_l !== undefined) ? (side_l*scale) * Math.sin(actual_angle_rad) : 
                                 ( (side_a !== null && side_a !== undefined && actual_angle_rad > 0.01 && actual_angle_rad < Math.PI/2 - 0.01) ? (side_a*scale) * Math.tan(actual_angle_rad) : 10*scale*Math.tan(actual_angle_rad) ) ) );
            
            const final_scaled_a = Math.max(1, scaled_a_val); 
            const final_scaled_o = Math.max(1, scaled_o_val);

            const Cx = PADDING;
            const Cy = svgHeight - PADDING;
            const Ax = Cx + final_scaled_a;
            const Ay = Cy;
            const Bx = Cx;
            const By = Cy - final_scaled_o;

            const group = svg.append("g");

            const sidesData = [
                { id: 'AC', x1: Cx, y1: Cy, x2: Ax, y2: Ay, label: labelA, value: side_a, key: 'A', name: "Aanliggende" },
                { id: 'BC', x1: Cx, y1: Cy, x2: Bx, y2: By, label: labelO, value: side_o, key: 'O', name: "Overstaande" },
                { id: 'AB', x1: Ax, y1: Ay, x2: Bx, y2: By, label: labelL, value: side_l, key: 'L', name: "Langste" }
            ];
            
            const isHighlighted = (key) => highlightKeys && (Array.isArray(highlightKeys) ? highlightKeys.includes(key) : highlightKeys === key);

            group.selectAll("line.triangle-side")
                .data(sidesData)
                .join(
                    enter => enter.append("line")
                        .attr("class", "triangle-side")
                        .attr("x1", d => d.x1).attr("y1", d => d.y1)
                        .attr("x2", d => d.x1).attr("y2", d => d.y1) 
                        .attr("stroke", d => isHighlighted(d.key) ? "#d9534f" : "#333")
                        .attr("stroke-width", d => isHighlighted(d.key) ? (customWidth ? 2.5 : 3.5) : (customWidth ? 1.5 : 2))
                        .transition().duration(customWidth ? 300 : 750) 
                        .attr("x2", d => d.x2).attr("y2", d => d.y2),
                    update => update 
                        .transition().duration(customWidth ? 300 : 750)
                        .attr("x1", d => d.x1).attr("y1", d => d.y1)
                        .attr("x2", d => d.x2).attr("y2", d => d.y2)
                        .attr("stroke", d => isHighlighted(d.key) ? "#d9534f" : "#333")
                        .attr("stroke-width", d => isHighlighted(d.key) ? (customWidth ? 2.5 : 3.5) : (customWidth ? 1.5 : 2))
                );
            
            const vertexData = [
                { id: 'A', x: Ax + (customWidth ? 4 : 8), y: Ay + (customWidth ? 9 : 18), label: 'A' },
                { id: 'B', x: Bx - (customWidth ? 5 : 10), y: By - (customWidth ? 4 : 8), label: 'B' },
                { id: 'C', x: Cx - (customWidth ? 7 : 15), y: Cy + (customWidth ? 7 : 15), label: 'C' }
            ];
            group.selectAll("text.vertex-label")
                .data(vertexData).join("text")
                .attr("class", "vertex-label")
                .attr("x", d => d.x).attr("y", d => d.y)
                .text(d => d.label)
                .style("font-size", customWidth ? "10px" : "14px")
                .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 200:600).style("opacity", 1);

            group.selectAll("text.side-label")
                .data(sidesData.filter(d => (d.value !== null && d.value !== undefined) || (isHighlighted(d.key) && showSidePrefixes))) 
                .join("text")
                .attr("class", "side-label")
                .attr("x", d => { 
                    if (d.id === 'AC') return (d.x1 + d.x2) / 2;
                    if (d.id === 'BC') return d.x1 - (customWidth ? 5 : 10); 
                    return (d.x1 + d.x2) / 2; 
                })
                .attr("y", d => { 
                    if (d.id === 'AC') return d.y1 + (customWidth ? 10 : 20); 
                    if (d.id === 'BC') return (d.y1 + d.y2) / 2 + (customWidth ? 2 : 4); 
                    return (d.y1 + d.y2) / 2 - (customWidth ? 6 : 12); 
                })
                .attr("transform", d => {
                    if (d.id === 'AB' && (showSidePrefixes || (d.value !== null && d.value !== undefined))) { 
                         const angleRad = Math.atan2(By - Ay, Bx - Ax); 
                         let textAngle = toDegrees(angleRad);
                         if (textAngle < -45 && textAngle > -135) textAngle += 0; 
                         else if (textAngle > 45 && textAngle < 135) textAngle += 0;
                         return `rotate(${textAngle}, ${(d.x1+d.x2)/2}, ${(d.y1+d.y2)/2})`;
                    }
                    return ""; 
                })
                .attr("text-anchor", d => (d.id === 'BC' ? "end" : "middle"))
                .text(d => {
                    let labelText;
                    const valueText = (d.value !== null && d.value !== undefined) ? d.value.toFixed(1) : '?';
                    const prefix = d.label.split(" ")[0]; 

                    if (showSidePrefixes) {
                        labelText = `${prefix}: ${valueText}`;
                        if (valueText === '?' && isHighlighted(d.key)) { 
                             labelText = `${prefix} (${d.name.substring(0,Math.min(d.name.length,6))}...): ?`; 
                        }
                    } else { 
                        labelText = valueText;
                    }
                    return labelText;
                })
                .style("fill", d => isHighlighted(d.key) ? "#d9534f" : "#007bff")
                .style("font-weight", d => isHighlighted(d.key) ? "bold" : "normal")
                .style("font-size", customWidth ? "9px" : "12px")
                .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 250:700).style("opacity", 1);

            let angleDisplayText = "";
            const anglePrefix = labelAngleA.split(" ")[0];

            if (angleA_deg !== null && angleA_deg !== undefined) {
                angleDisplayText = `${anglePrefix}: ${angleA_deg.toFixed(1)}¬∞`;
            } else if (isHighlighted('angleA') && showSidePrefixes) { 
                angleDisplayText = `${anglePrefix}: ?`;
            } else if (isAngleQuestion && !showSidePrefixes && !isHighlighted('angleA')) { 
                 angleDisplayText = `${anglePrefix}: ?`;
            }


            if (angleDisplayText) {
                group.append("text")
                    .attr("class", "angle-label-text")
                    .attr("x", Ax - (customWidth ? 15 : (final_scaled_a > 30 ? 30: 15)) )
                    .attr("y", Ay - (customWidth ? 5 : 10))
                    .text(angleDisplayText)
                    .style("font-size", customWidth ? "9px" : "12px")
                    .style("fill", isHighlighted('angleA') ? "#d9534f" : "red")
                    .style("font-weight", isHighlighted('angleA') ? "bold" : "bold")
                    .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 250:700).style("opacity", 1);
            }
            
            if (angleA_deg !== null && angleA_deg !== undefined) { 
                const arcRadius = Math.min((customWidth ? 12 : 25), final_scaled_a / 3, final_scaled_o / 3);
                if (arcRadius > (customWidth ? 2 : 5)) { 
                     const arcGenerator = d3.arc()
                        .innerRadius(arcRadius - (customWidth ? 1 : 2))
                        .outerRadius(arcRadius)
                        .startAngle(Math.PI) 
                        .endAngle(Math.PI + toRadians(angleA_deg)); 
                    group.append("path")
                        .attr("transform", `translate(${Ax}, ${Ay})`) 
                        .attr("d", arcGenerator)
                        .attr("fill", isHighlighted('angleA') ? "rgba(255,0,0,0.5)" : "rgba(255,0,0,0.3)")
                        .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 300:750).style("opacity", 1);
                }
            }

            group.append("path")
                .attr("class", "right-angle-symbol")
                .attr("d", `M ${Cx + (customWidth ? 5:10)} ${Cy} L ${Cx + (customWidth ? 5:10)} ${Cy - (customWidth ? 5:10)} L ${Cx} ${Cy - (customWidth ? 5:10)}`) 
                .style("opacity", 0).transition().duration(customWidth ? 200:500).delay(customWidth ? 250:700).style("opacity", 1);
        }

        function newQuestion() {
            answerElement.value = '';
            feedbackElement.innerHTML = '';
            uitlegFoutElement.style.display = 'none';
            uitlegStappenContainer.innerHTML = ''; 
            
            updateStreakDisplay();

            let questionCategory; 
            let mainType; 
            let subType; 

            let selectedQuestionPool = [];
            if (selectSinSidesCb.checked) {
                selectedQuestionPool.push({category: 0, mainType: 0}); // 0 for Sinus
            }
            if (selectCosSidesCb.checked) {
                selectedQuestionPool.push({category: 0, mainType: 1}); // 1 for Cosinus
            }
            if (selectTanSidesCb.checked) {
                selectedQuestionPool.push({category: 0, mainType: 2}); // 2 for Tangens
            }
            if (selectAnglesCb.checked) {
                selectedQuestionPool.push({category: 1, mainType: 0}); // Angle via Sin
                selectedQuestionPool.push({category: 1, mainType: 1}); // Angle via Cos
                selectedQuestionPool.push({category: 1, mainType: 2}); // Angle via Tan
            }

            if (selectedQuestionPool.length === 0) { 
                selectSinSidesCb.checked = true;
                selectCosSidesCb.checked = true;
                selectTanSidesCb.checked = true;
                selectAnglesCb.checked = true;
                selectedQuestionPool = [ // Repopulate with all
                    {category: 0, mainType: 0}, {category: 0, mainType: 1}, {category: 0, mainType: 2},
                    {category: 1, mainType: 0}, {category: 1, mainType: 1}, {category: 1, mainType: 2}
                ];
                if(feedbackElement.innerHTML === '') { // Only show message if no other feedback is present
                     feedbackElement.innerHTML = "<span class='incorrect'>Geen type geselecteerd. Alle types worden nu gebruikt.</span>";
                }
            }


            if (lastQuestionTypeOnError) {
                const errorTypeStillSelected = selectedQuestionPool.some(
                    type => type.category === lastQuestionTypeOnError.category && type.mainType === lastQuestionTypeOnError.mainType
                );
                if (errorTypeStillSelected) {
                    questionCategory = lastQuestionTypeOnError.category;
                    mainType = lastQuestionTypeOnError.mainType;
                    subType = lastQuestionTypeOnError.subType; 
                } else { 
                    const chosenType = selectedQuestionPool[Math.floor(Math.random() * selectedQuestionPool.length)];
                    questionCategory = chosenType.category;
                    mainType = chosenType.mainType;
                    subType = undefined; // Reset subType as it depends on the new mainType if it's a side question
                }
                lastQuestionTypeOnError = null; 
            } else {
                const chosenType = selectedQuestionPool[Math.floor(Math.random() * selectedQuestionPool.length)];
                questionCategory = chosenType.category;
                mainType = chosenType.mainType;
                subType = undefined; // Reset subType
            }
            
            if (questionCategory === 0 && subType === undefined) { 
                subType = Math.random() < 0.5 ? 0 : 1; 
            }


            currentQuestionData.category = questionCategory;
            currentQuestionData.mainType = mainType;
            currentQuestionData.subType = subType; 


            let angleA, knownSideValue, side_l_calc, side_o_calc, side_a_calc, teVindenKey, knownSideKey, knownSideVal;
            let calculationDescription = "";
            currentQuestionData.isAngleQuestion = (questionCategory === 1);

            if (!currentQuestionData.isAngleQuestion) { 
                answerLabelElement.textContent = "Antwoord (zijde, 1 decimaal):";
                angleA = Math.floor(Math.random() * 50) + 20; 
                currentQuestionData.angleA = angleA;
                knownSideValue = parseFloat((Math.random() * 15 + 5).toFixed(1)); 

                if (mainType === 0) { // Sinus
                    if (subType === 0) { 
                        side_l_calc = knownSideValue; teVindenKey = 'O'; knownSideKey = 'L'; knownSideVal = side_l_calc;
                        currentQuestionData.correctAnswer = side_l_calc * Math.sin(toRadians(angleA));
                        side_o_calc = currentQuestionData.correctAnswer;
                        side_a_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_o_calc**2));
                        questionElement.innerText = `Hoek A = ${angleA}¬∞, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken de Overstaande zijde (O) van hoek A.`;
                        currentQuestionData.rule = "SOL: sin(A) = O / L  =>  O = L * sin(A)";
                        calculationDescription = `O = ${side_l_calc.toFixed(1)} * sin(${angleA}¬∞)`;
                    } else { 
                        side_o_calc = knownSideValue; teVindenKey = 'L'; knownSideKey = 'O'; knownSideVal = side_o_calc;
                        currentQuestionData.correctAnswer = side_o_calc / Math.sin(toRadians(angleA));
                        side_l_calc = currentQuestionData.correctAnswer;
                        side_a_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_o_calc**2));
                        questionElement.innerText = `Hoek A = ${angleA}¬∞, Overstaande zijde (O) = ${side_o_calc.toFixed(1)}. Bereken de Langste zijde (L).`;
                        currentQuestionData.rule = "SOL: sin(A) = O / L  =>  L = O / sin(A)";
                        calculationDescription = `L = ${side_o_calc.toFixed(1)} / sin(${angleA}¬∞)`;
                    }
                } else if (mainType === 1) { // Cosinus
                    if (subType === 0) { 
                        side_l_calc = knownSideValue; teVindenKey = 'A'; knownSideKey = 'L'; knownSideVal = side_l_calc;
                        currentQuestionData.correctAnswer = side_l_calc * Math.cos(toRadians(angleA));
                        side_a_calc = currentQuestionData.correctAnswer;
                        side_o_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_a_calc**2));
                        questionElement.innerText = `Hoek A = ${angleA}¬∞, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken de Aanliggende zijde (A) van hoek A.`;
                        currentQuestionData.rule = "CAL: cos(A) = A / L  =>  A = L * cos(A)";
                        calculationDescription = `A = ${side_l_calc.toFixed(1)} * cos(${angleA}¬∞)`;
                    } else { 
                        side_a_calc = knownSideValue; teVindenKey = 'L'; knownSideKey = 'A'; knownSideVal = side_a_calc;
                        currentQuestionData.correctAnswer = side_a_calc / Math.cos(toRadians(angleA));
                        side_l_calc = currentQuestionData.correctAnswer;
                        side_o_calc = Math.sqrt(Math.max(0.1,side_l_calc**2 - side_a_calc**2));
                        questionElement.innerText = `Hoek A = ${angleA}¬∞, Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}. Bereken de Langste zijde (L).`;
                        currentQuestionData.rule = "CAL: cos(A) = A / L  =>  L = A / cos(A)";
                        calculationDescription = `L = ${side_a_calc.toFixed(1)} / cos(${angleA}¬∞)`;
                    }
                } else { // Tangens
                    if (subType === 0) { 
                        side_a_calc = knownSideValue; teVindenKey = 'O'; knownSideKey = 'A'; knownSideVal = side_a_calc;
                        currentQuestionData.correctAnswer = side_a_calc * Math.tan(toRadians(angleA));
                        side_o_calc = currentQuestionData.correctAnswer;
                        side_l_calc = Math.sqrt(side_a_calc**2 + side_o_calc**2);
                        questionElement.innerText = `Hoek A = ${angleA}¬∞, Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}. Bereken de Overstaande zijde (O) van hoek A.`;
                        currentQuestionData.rule = "TOA: tan(A) = O / A  =>  O = A * tan(A)";
                        calculationDescription = `O = ${side_a_calc.toFixed(1)} * tan(${angleA}¬∞)`;
                    } else { 
                        side_o_calc = knownSideValue; teVindenKey = 'A'; knownSideKey = 'O'; knownSideVal = side_o_calc;
                        currentQuestionData.correctAnswer = side_o_calc / Math.tan(toRadians(angleA));
                        side_a_calc = currentQuestionData.correctAnswer;
                        side_l_calc = Math.sqrt(side_a_calc**2 + side_o_calc**2);
                        questionElement.innerText = `Hoek A = ${angleA}¬∞, Overstaande zijde (O) = ${side_o_calc.toFixed(1)}. Bereken de Aanliggende zijde (A) van hoek A.`;
                        currentQuestionData.rule = "TOA: tan(A) = O / A  =>  A = O / tan(A)";
                        calculationDescription = `A = ${side_o_calc.toFixed(1)} / tan(${angleA}¬∞)`;
                    }
                }
            } else { 
                answerLabelElement.textContent = "Antwoord (hoek in graden, 1 decimaal):";
                teVindenKey = 'angleA'; 
                let side1Val = parseFloat((Math.random() * 10 + 5).toFixed(1)); 
                let side2Val = parseFloat((Math.random() * 10 + 5).toFixed(1)); 

                if (mainType === 0) { 
                    side_o_calc = Math.min(side1Val, side2Val);
                    side_l_calc = Math.max(side1Val, side2Val) + parseFloat((Math.random()*5+1).toFixed(1)); 
                    if (side_o_calc >= side_l_calc) side_l_calc = side_o_calc + parseFloat((Math.random()*2+0.5).toFixed(1)); 
                    side_a_calc = Math.sqrt(Math.max(0.1, side_l_calc**2 - side_o_calc**2));
                    currentQuestionData.correctAnswer = toDegrees(Math.asin(side_o_calc / side_l_calc));
                    knownSideKey = ['O', 'L']; knownSideVal = [side_o_calc, side_l_calc];
                    questionElement.innerText = `Overstaande zijde (O) = ${side_o_calc.toFixed(1)}, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken hoek A.`;
                    currentQuestionData.rule = "SOL: sin(A) = O / L  =>  A = sin‚Åª¬π(O / L)";
                    calculationDescription = `A = sin‚Åª¬π(${side_o_calc.toFixed(1)} / ${side_l_calc.toFixed(1)})`;
                } else if (mainType === 1) { 
                    side_a_calc = Math.min(side1Val, side2Val);
                    side_l_calc = Math.max(side1Val, side2Val) + parseFloat((Math.random()*5+1).toFixed(1)); 
                    if (side_a_calc >= side_l_calc) side_l_calc = side_a_calc + parseFloat((Math.random()*2+0.5).toFixed(1)); 
                    side_o_calc = Math.sqrt(Math.max(0.1, side_l_calc**2 - side_a_calc**2));
                    currentQuestionData.correctAnswer = toDegrees(Math.acos(side_a_calc / side_l_calc));
                    knownSideKey = ['A', 'L']; knownSideVal = [side_a_calc, side_l_calc];
                    questionElement.innerText = `Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}, Langste zijde (L) = ${side_l_calc.toFixed(1)}. Bereken hoek A.`;
                    currentQuestionData.rule = "CAL: cos(A) = A / L  =>  A = cos‚Åª¬π(A / L)";
                    calculationDescription = `A = cos‚Åª¬π(${side_a_calc.toFixed(1)} / ${side_l_calc.toFixed(1)})`;
                } else { 
                    side_o_calc = side1Val;
                    side_a_calc = side2Val;
                    side_l_calc = Math.sqrt(side_o_calc**2 + side_a_calc**2);
                    currentQuestionData.correctAnswer = toDegrees(Math.atan(side_o_calc / side_a_calc));
                    knownSideKey = ['O', 'A']; knownSideVal = [side_o_calc, side_a_calc];
                    questionElement.innerText = `Overstaande zijde (O) = ${side_o_calc.toFixed(1)}, Aanliggende zijde (A) = ${side_a_calc.toFixed(1)}. Bereken hoek A.`;
                    currentQuestionData.rule = "TOA: tan(A) = O / A  =>  A = tan‚Åª¬π(O / A)";
                    calculationDescription = `A = tan‚Åª¬π(${side_o_calc.toFixed(1)} / ${side_a_calc.toFixed(1)})`;
                }
                angleA = currentQuestionData.correctAnswer; 
                currentQuestionData.angleA = angleA; 
            }

            currentQuestionData.calculation = calculationDescription;
            currentQuestionData.teVindenKey = teVindenKey;
            currentQuestionData.knownSideKey = knownSideKey; 
            currentQuestionData.knownSideValue = knownSideVal; 
            
            currentQuestionData.full_side_l = side_l_calc;
            currentQuestionData.full_side_o = side_o_calc;
            currentQuestionData.full_side_a = side_a_calc;

            let q_l = null, q_o = null, q_a = null;
            let angleForDrawing = null; 

            if (currentQuestionData.isAngleQuestion) {
                q_l = side_l_calc; q_o = side_o_calc; q_a = side_a_calc;
                angleForDrawing = null; 
                drawTriangleGeneric("questionTriangleSvg", angleForDrawing, q_l, q_o, q_a, "A", "L", "O", "A", knownSideKey, null, null, false, true);
            } else { 
                angleForDrawing = angleA; 
                if (knownSideKey === 'L') q_l = currentQuestionData.knownSideValue;
                else if (knownSideKey === 'O') q_o = currentQuestionData.knownSideValue;
                else if (knownSideKey === 'A') q_a = currentQuestionData.knownSideValue;
                
                if (teVindenKey === 'L') q_l = null;
                else if (teVindenKey === 'O') q_o = null;
                else if (teVindenKey === 'A') q_a = null;
                
                if (q_l === null && teVindenKey !== 'L') q_l = currentQuestionData.full_side_l;
                if (q_o === null && teVindenKey !== 'O') q_o = currentQuestionData.full_side_o;
                if (q_a === null && teVindenKey !== 'A') q_a = currentQuestionData.full_side_a;

                drawTriangleGeneric("questionTriangleSvg", angleForDrawing, q_l, q_o, q_a, "A", "L", "O", "A", teVindenKey, null, null, false, false);
            }
        }

        function toonUitlegStappen(data) {
            uitlegStappenContainer.innerHTML = ''; 
            uitlegFoutElement.style.display = 'block'; 

            const stepWidth = 200, stepHeight = 150;

            const stap1Div = d3.select(uitlegStappenContainer).append("div").attr("class", "stap-uitleg");
            stap1Div.append("h5").text("Stap 1: Wat weten we?");
            const svg1 = stap1Div.append("svg").attr("width", stepWidth).attr("height", stepHeight);
            
            let s1_l_draw = data.full_side_l, s1_o_draw = data.full_side_o, s1_a_draw = data.full_side_a;
            let s1_angle_to_show = data.isAngleQuestion ? null : data.angleA; 

            drawTriangleGeneric(svg1, s1_angle_to_show, s1_l_draw, s1_o_draw, s1_a_draw, "A", "L", "O", "A", data.knownSideKey, stepWidth, stepHeight, true, data.isAngleQuestion);
            let gegevenText = data.isAngleQuestion ? `Gegeven: ${Array.isArray(data.knownSideKey) ? data.knownSideKey.map((k,i) => `${k === 'L' ? 'Langste' : (k === 'O' ? 'Overstaande' : 'Aanliggende')} = ${data.knownSideValue[i].toFixed(1)}`).join(', ') : ''}.`
                                                : `Gegeven: Hoek A = ${data.angleA.toFixed(1)}¬∞, ${data.knownSideKey === 'L' ? 'Langste' : (data.knownSideKey === 'O' ? 'Overstaande' : 'Aanliggende')} zijde = ${data.knownSideValue.toFixed(1)}.`;
            stap1Div.append("p").html(gegevenText);


            const stap2Div = d3.select(uitlegStappenContainer).append("div").attr("class", "stap-uitleg");
            stap2Div.append("h5").text("Stap 2: Formule kiezen en invullen");
            const svg2 = stap2Div.append("svg").attr("width", stepWidth).attr("height", stepHeight);
            
            let highlightFormuleKeys = [];
            if (data.rule.includes("SOL")) highlightFormuleKeys = ['O', 'L'];
            else if (data.rule.includes("CAL")) highlightFormuleKeys = ['A', 'L'];
            else if (data.rule.includes("TOA")) highlightFormuleKeys = ['O', 'A'];
            
            if (data.isAngleQuestion) { 
                highlightFormuleKeys.push('angleA');
            } else { 
                 highlightFormuleKeys.push(data.teVindenKey);
            }
            
            let s2_angle_to_show = data.isAngleQuestion ? null : data.angleA;
            drawTriangleGeneric(svg2, s2_angle_to_show, data.full_side_l, data.full_side_o, data.full_side_a, "A", "L", "O", "A", highlightFormuleKeys, stepWidth, stepHeight, true, data.isAngleQuestion);
            let teZoekenText = data.isAngleQuestion ? `Hoek A` : `de ${data.teVindenKey === 'L' ? 'Langste' : (data.teVindenKey === 'O' ? 'Overstaande' : 'Aanliggende')} zijde`;
            stap2Div.append("p").html(`We zoeken ${teZoekenText}.<br>
                                     Gebruik de regel: ${data.rule.split("=>")[0]}.<br>
                                     Invullen: ${data.calculation}.`);

            const stap3Div = d3.select(uitlegStappenContainer).append("div").attr("class", "stap-uitleg");
            stap3Div.append("h5").text("Stap 3: De Oplossing");
            const svg3 = stap3Div.append("svg").attr("width", stepWidth).attr("height", stepHeight);
            drawTriangleGeneric(svg3, data.angleA, data.full_side_l, data.full_side_o, data.full_side_a, "A", "L", "O", "A", [data.teVindenKey], stepWidth, stepHeight, true, data.isAngleQuestion);
            let oplossingText = data.isAngleQuestion ? `Hoek A is ongeveer <strong>${data.correctAnswer.toFixed(1)}¬∞</strong>.`
                                                  : `De ${data.teVindenKey === 'L' ? 'Langste' : (data.teVindenKey === 'O' ? 'Overstaande' : 'Aanliggende')} zijde is ongeveer <strong>${data.correctAnswer.toFixed(1)}</strong>.`;
            stap3Div.append("p").html(oplossingText);
        }


        function checkAnswer() {
            const userAnswer = parseFloat(answerElement.value);
            if (isNaN(userAnswer)) {
                feedbackElement.innerHTML = "<span class='incorrect'>Voer alsjeblieft een getal in.</span>";
                uitlegStappenContainer.innerHTML = '';
                uitlegFoutElement.style.display = 'none';
                return;
            }
            const correctAnswerRounded = parseFloat(currentQuestionData.correctAnswer.toFixed(1));
            const userAnswerRounded = parseFloat(userAnswer.toFixed(1));

            if (userAnswerRounded === correctAnswerRounded) {
                feedbackElement.innerHTML = `<span class='correct'>üéâ Goed zo! Het antwoord is (ongeveer) ${correctAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}.</span>`;
                currentStreak++;
                lastQuestionTypeOnError = null; 
            } else {
                feedbackElement.innerHTML = `<span class='incorrect'>üò• Helaas, niet correct. Juiste antwoord: ${correctAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}. Jouw antwoord: ${userAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}.</span>`;
                currentStreak = 0;
                lastQuestionTypeOnError = { 
                    category: currentQuestionData.category,
                    mainType: currentQuestionData.mainType,
                    subType: currentQuestionData.subType 
                };
            }
            updateStreakDisplay();
            uitlegFoutRegel.textContent = currentQuestionData.rule;
            uitlegFoutBerekening.textContent = currentQuestionData.calculation + ` ‚âà ${correctAnswerRounded}${(currentQuestionData.isAngleQuestion ? '¬∞' : '')}`;
            toonUitlegStappen(currentQuestionData); 
        }

        answerElement.addEventListener('keypress', function(event) { if (event.key === 'Enter') checkAnswer(); });
        
        window.onload = function() { 
            newQuestion(); 
            if (document.getElementById('explanationTriangleSvg').childNodes.length === 0 && explanationDiv.style.display === 'block') {
                 drawExplanationTriangle(); 
            }
        };
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$']], displayMath: [['$$','$$']], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] }, messageStyle: "none" });
    </script>
</body>
</html>
